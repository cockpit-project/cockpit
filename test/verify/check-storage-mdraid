#!/usr/bin/python3 -cimport os, sys; os.execv(os.path.dirname(sys.argv[1]) + "/../common/pywrap", sys.argv)

# This file is part of Cockpit.
#
# Copyright (C) 2015 Red Hat, Inc.
#
# Cockpit is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# Cockpit is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.

from time import sleep

import storagelib
import testlib


class TestStorageMdRaid(storagelib.StorageCase):

    def wait_states(self, states):
        for s in states.keys():
            self.browser.wait_in_text(self.card_row("MDRAID device", name=s), states[s])

    def raid_add_disk(self, name):
        self.dialog_open_with_retry(trigger=lambda: self.browser.click(self.card_button("MDRAID device", "Add disk")),
                                    expect=lambda: self.dialog_is_present('disks', name))
        self.dialog_set_val("disks", {name: True})
        self.dialog_apply_with_retry()

    def raid_remove_disk(self, name):
        self.click_dropdown(self.card_row("MDRAID device", name=name), "Remove")

    def raid_action(self, action):
        self.browser.click(self.card_button("MDRAID device", action))

    def raid_default_action_start(self, action):
        self.raid_action(action)

    def raid_default_action_finish(self, action):
        if action == "Stop":
            # Right after assembling an array the device might be busy
            # from udev rules probing or the mdadm monitor; retry a
            # few times.  Also, it might come back spontaneously after
            # having been stopped successfully; wait a bit before
            # checking whether it is really off.
            for _ in range(3):
                try:
                    sleep(10)
                    self.browser.wait_text(self.card_desc("MDRAID device", "State"), "Not running")
                    break
                except testlib.Error as ex:
                    if not ex.msg.startswith('timeout'):
                        raise
                    print("Stopping failed, retrying...")
                    if self.browser.is_present("#dialog"):
                        self.browser.wait_in_text("#dialog", "Error stopping RAID array")
                        self.dialog_cancel()
                        self.dialog_wait_close()
                    self.raid_default_action_start(action)
            else:
                self.fail("Timed out waiting for array to get stopped")

    def raid_default_action(self, action):
        self.raid_default_action_start(action)
        self.raid_default_action_finish(action)

    def testRaid(self):
        m = self.machine
        b = self.browser

        self.login_and_go("/storage")

        # Add four disks and make a RAID out of three of them
        disk1 = "/dev/" + m.add_disk("50M", serial="DISK1")["dev"]
        b.wait_visible(self.card_row("Storage", name=disk1))
        disk2 = "/dev/" + m.add_disk("50M", serial="DISK2")["dev"]
        b.wait_visible(self.card_row("Storage", name=disk2))
        disk3 = "/dev/" + m.add_disk("50M", serial="DISK3")["dev"]
        b.wait_visible(self.card_row("Storage", name=disk3))
        disk4 = "/dev/" + m.add_disk("50M", serial="DISK4")["dev"]
        b.wait_visible(self.card_row("Storage", name=disk4))

        self.click_devices_dropdown('Create MDRAID device')
        self.dialog_wait_open()
        self.dialog_wait_val("name", "raid0")
        self.dialog_wait_val("level", "raid5")
        self.dialog_apply()
        self.dialog_wait_error("disks", "At least 2 disks are needed")
        self.dialog_set_val("disks", {disk1: True})
        self.dialog_apply()
        self.dialog_wait_error("disks", "At least 2 disks are needed")
        self.dialog_set_val("disks", {disk2: True, disk3: True})
        self.dialog_set_val("level", "raid6")
        self.dialog_apply()
        self.dialog_wait_error("disks", "At least 4 disks are needed")
        self.dialog_set_val("level", "raid5")
        self.dialog_set_val("name", "raid 0")
        self.dialog_apply()
        self.dialog_wait_error("name", "Name cannot contain whitespace.")
        self.dialog_set_val("name", "raid0")
        self.dialog_apply()
        self.dialog_wait_close()
        b.wait_visible(self.card_row("Storage", name="/dev/md/raid0"))

        # Check that Cockpit suggest name that does not yet exists
        self.click_devices_dropdown('Create MDRAID device')
        b.wait(lambda: self.dialog_val("name") == "raid1")
        self.dialog_cancel()
        self.dialog_wait_close()

        self.click_card_row("Storage", name="/dev/md/raid0")

        self.wait_states({disk1: "In sync",
                          disk2: "In sync",
                          disk3: "In sync"})

        def wait_degraded_state(is_degraded):
            degraded_selector = ".pf-v5-c-alert h4"
            if is_degraded:
                b.wait_in_text(degraded_selector, 'The MDRAID device is in a degraded state')
            else:
                b.wait_not_present(degraded_selector)

        # The preferred device should be /dev/md/raid0, but a freshly
        # created array seems to have no symlink in /dev/md/.
        #
        # See https://bugzilla.redhat.com/show_bug.cgi?id=1397320
        #
        dev = b.text(self.card_desc("MDRAID device", "Device"))

        # Degrade and repair it

        m.execute(f"mdadm --quiet {dev} --fail /dev/disk/by-id/scsi-0QEMU_QEMU_HARDDISK_DISK1; udevadm trigger")
        wait_degraded_state(is_degraded=True)

        self.wait_states({disk1: "Failed"})
        self.raid_remove_disk(disk1)
        b.wait_not_present(self.card_row("Disks", name=disk1))

        self.raid_add_disk(disk1)
        self.wait_states({disk1: "In sync",
                          disk2: "In sync",
                          disk3: "In sync"})

        wait_degraded_state(is_degraded=False)

        # Turn it off and on again
        with b.wait_timeout(30):
            self.raid_default_action("Stop")
            b.wait_text(self.card_desc("MDRAID device", "State"), "Not running")
            self.raid_default_action("Start")
            b.wait_text(self.card_desc("MDRAID device", "State"), "Running")

        # Stopping and starting the array should not change the device.
        #
        b.wait_text(self.card_desc("MDRAID device", "Device"), "/dev/md/raid0")

        # Partitions also get symlinks in /dev/md/, so they should
        # have names like "/dev/md/raid0p1".
        #
        part_prefix = "md/raid0p"

        # Create Partition Table
        self.click_card_dropdown("MDRAID device", "Create partition table")
        self.dialog({"type": "gpt"})
        b.wait_text(self.card_row_col("GPT partitions", 1, 1), "Free space")

        # Create first partition
        self.click_dropdown(self.card_row("GPT partitions", 1), "Create partition")
        self.dialog({"size": 20,
                     "type": "ext4",
                     "mount_point": "/foo1",
                     "name": "One"},
                    secondary=True)
        b.wait_text(self.card_row_col("GPT partitions", 1, 2), "ext4 filesystem")
        b.wait_text(self.card_row_col("GPT partitions", 1, 1), part_prefix + "1")

        # Create second partition
        self.click_dropdown(self.card_row("GPT partitions", 2), "Create partition")
        self.dialog({"type": "ext4",
                     "mount_point": "/foo2",
                     "name": "Two"})
        b.wait_text(self.card_row_col("GPT partitions", 2, 2), "ext4 filesystem")
        b.wait_text(self.card_row_col("GPT partitions", 2, 1), part_prefix + "2")
        b.wait_not_present(self.card_row("GPT partitions", name="Free space"))

        b.wait_visible(self.card_row("GPT partitions", location="/foo2") + " .usage-bar[role=progressbar]")
        b.assert_pixels('body', "page",
                        ignore=[self.card_desc("MDRAID device", "UUID")])

        # Replace a disk by adding a spare and then removing a "In sync" disk

        # Add a spare
        self.raid_add_disk(disk4)
        self.wait_states({disk4: "Spare"})

        # Remove DISK1.  The spare takes over.
        self.raid_remove_disk(disk1)
        try:
            b.wait_not_present(self.card_row("MDRAID device", name=disk1))
        except testlib.Error:
            # Sometimes disk1 is busy. Try again in that case
            if b.is_visible("#dialog") and "Device or resource busy" in b.text("#dialog"):
                self.dialog_cancel()
                self.dialog_wait_close()
                self.raid_remove_disk(disk1)
                b.wait_not_present(self.card_row("MDRAID device", name=disk1))
            else:
                raise

        self.wait_states({disk4: "In sync"})

        # Stop the array, destroy a disk, and start the array
        self.raid_default_action_start("Stop")
        self.dialog_wait_open()
        b.wait_in_text('#dialog', "unmount, stop")
        b.assert_pixels('#dialog', "stop-busy")
        self.dialog_apply()
        self.dialog_wait_close()
        self.raid_default_action_finish("Stop")
        b.wait_text(self.card_desc("MDRAID device", "State"), "Not running")
        m.execute("wipefs -a /dev/disk/by-id/scsi-0QEMU_QEMU_HARDDISK_DISK2")
        b.wait_not_present(self.card_row("MDRAID device", name=disk2))
        self.raid_default_action("Start")
        b.wait_text(self.card_desc("MDRAID device", "State"), "Running")
        wait_degraded_state(is_degraded=True)

        # Add DISK1.  The array recovers.
        self.raid_add_disk(disk1)
        self.wait_states({disk1: "In sync"})
        wait_degraded_state(is_degraded=False)

        # Add DISK2 again, as a spare
        self.raid_add_disk(disk2)
        self.wait_states({disk2: "Spare"})

        # Remove it by formatting DISK2
        self.click_card_row("MDRAID device", name=disk2)
        self.click_card_dropdown("Hard Disk Drive", "Create partition table")
        b.wait_in_text('#dialog', "remove from MDRAID, initialize")
        self.dialog_set_val("type", "empty")
        self.dialog_apply()
        self.dialog_wait_close()

        b.go("#/")
        self.click_card_row("Storage", name="/dev/md/raid0")
        b.wait_visible(self.card("MDRAID device"))
        b.wait_not_present(self.card_row("MDRAID device", name=disk2))

        # Delete the array.  We are back on the storage page.
        self.click_card_dropdown("MDRAID device", "Delete")
        self.confirm()
        with b.wait_timeout(120):
            b.wait_visible(self.card("Storage"))
            b.wait_not_present(self.card_row("Storage", name="/dev/md/raid0"))

    def testNotRemovingDisks(self):
        m = self.machine
        b = self.browser

        self.login_and_go("/storage")

        disk1 = "/dev/" + m.add_disk("50M", serial="DISK1")["dev"]
        b.wait_visible(self.card_row("Storage", name=disk1))
        disk2 = "/dev/" + m.add_disk("50M", serial="DISK2")["dev"]
        b.wait_visible(self.card_row("Storage", name=disk2))
        disk3 = "/dev/" + m.add_disk("50M", serial="DISK3")["dev"]
        b.wait_visible(self.card_row("Storage", name=disk3))

        self.click_devices_dropdown('Create MDRAID device')
        self.dialog_wait_open()
        self.dialog_set_val("level", "raid5")
        self.dialog_set_val("disks", {disk1: True, disk2: True})
        self.dialog_set_val("name", "ARR")
        self.dialog_apply()
        self.dialog_wait_close()

        self.click_card_row("Storage", name="/dev/md/ARR")

        self.wait_states({disk1: "In sync",
                          disk2: "In sync"})

        # All buttons should be disabled when the array is stopped

        self.raid_default_action("Stop")
        b.wait_text(self.card_desc("MDRAID device", "State"), "Not running")

        b.wait_visible(self.card_button("MDRAID device", "Add disk") + ":disabled")
        self.check_dropdown_action_disabled(self.card_row("MDRAID device", name=disk1), "Remove", "The MDRAID device must be running")

        self.raid_default_action("Start")
        b.wait_text(self.card_desc("MDRAID device", "State"), "Running")

        # With a running array, we can add spares, but not remove "in-sync" disks
        b.wait_not_present(self.card_button("MDRAID device", "Add disk") + ":disabled")
        self.check_dropdown_action_disabled(self.card_row("MDRAID device", name=disk1), "Remove", "Need a spare disk")

        # Adding a spare will allow removal of the "in-sync" disks.
        self.raid_add_disk(disk3)
        self.wait_states({disk3: "Spare"})
        self.raid_remove_disk(disk1)
        self.wait_states({disk3: "In sync",
                          disk2: "In sync"})

        # Removing the disk will make the rest un-removable again
        self.check_dropdown_action_disabled(self.card_row("MDRAID device", name=disk3), "Remove", "Need a spare disk")

        # A failed disk can be removed
        dev = b.text(self.card_desc("MDRAID device", "Device"))
        m.execute(f"mdadm --quiet {dev} --fail /dev/disk/by-id/scsi-0QEMU_QEMU_HARDDISK_DISK3")
        self.wait_states({disk3: "Failed"})
        self.raid_remove_disk(disk3)
        b.wait_not_present(self.card_row("MDRAID device", name=disk3))

        # The last disk can not be removed
        self.check_dropdown_action_disabled(self.card_row("MDRAID device", name=disk2), "Remove", "Need a spare disk")

    def testBitmap(self):
        m = self.machine
        b = self.browser

        self.login_and_go("/storage")

        # Make two huge block devices, so that we can make a array
        # that is beyond the threshold where Cockpit and mdadm start
        # to worry about bitmaps.  The backing files are sparse, so
        # this is okay as long nobody actually writes a lot to these
        # devices.

        dev1 = self.add_loopback_disk(110000)
        dev2 = self.add_loopback_disk(110000)

        # We need to use "--assume-clean" so that mdraid doesn't try
        # to write 110GB to one of the devices during synchronization.

        m.execute(f"mdadm --create md0 --level=1 --assume-clean --run --raid-devices=2 {dev1} {dev2}")
        m.execute("udevadm trigger")

        self.click_card_row("Storage", name="/dev/md/md0")

        self.wait_states({dev1: "In sync",
                          dev2: "In sync"})

        b.wait_not_present('.pf-v5-c-alert:contains("This MDRAID device has no write-intent bitmap")')

        # Remove the bitmap, Cockpit should complain and let us put it back.

        m.execute("mdadm --grow --bitmap=none /dev/md/md0; udevadm trigger /dev/md/md0")

        b.wait_visible('.pf-v5-c-alert:contains("This MDRAID device has no write-intent bitmap")')
        b.click('button:contains("Add a bitmap")')
        b.wait_not_present('.pf-v5-c-alert:contains("This MDRAID device has no write-intent bitmap")')


if __name__ == '__main__':
    testlib.test_main()
