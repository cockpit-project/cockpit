#!/usr/bin/python3

import glob
import os
import string
import subprocess
import sys
import unittest
import dataclasses
import errno
import fcntl

import importlib.machinery
import importlib.util

import parent
import testlib
import testvm

sys.dont_write_bytecode = True
os.environ['PYTHONUNBUFFERED'] = '1'

@dataclasses.dataclass
class Test:
    test_id: int
    command: list
    process: subprocess.Popen = None
    retries: int = 0
    output: bytes = b""


def print_test(test):
    for line in test.output.strip().split(b"\n"):
        print(line.decode())

# returns if test should retry or not
def finish_test(opts, test):
    """Returns if a test should retry or not.
    Call test-policy on the test's output, print if needed.
    """
    test.output += test.process.stdout.read()

    if test.process.returncode == 0:
        print_test(test)
        if not opts.list:
            print("ok", test.test_id, test.command[0], test.command[-1])
        return False
    elif test.process.returncode == 77:
        print_test(test)
        print("ok", test.test_id, test.command[0], test.command[-1],
              test.output.decode().strip().split('\n')[-1])
        return False

    cmd = ["tests-policy", testvm.DEFAULT_IMAGE]
    try:
        proc = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        (changed, unused) = proc.communicate(test.output)
        if proc.returncode == 0:
            test.output = changed
    except OSError as ex:
        if ex.errno != errno.ENOENT:
            sys.stderr.write("Couldn't run tests-policy: {0}\n".format(str(ex)))

    if test.retries < 2:
        test.retries += 1
        test.output += "# RETRY {0}\n".format(test.retries).encode()
        print_test(test)
        print("not ok", test.test_id, test.command[0], test.command[-1])
        return True
    else:
        print_test(test)
        print("not ok", test.test_id, test.command[0], test.command[-1])
    return False

def check_valid(filename):
    name = os.path.basename(filename)
    allowed = string.ascii_letters + string.digits + '-_'
    if not all(c in allowed for c in name):
        return None
    return name.replace("-", "_")

def build_command(filename, test, opts):
    cmd = [filename]
    if opts.sit:
        cmd.append("-s")
    if opts.trace:
        cmd.append("-t")
    if opts.verbosity:
        cmd.append("-v")
    if opts.thorough:
        cmd.append("--thorough")
    if not opts.fetch:
        cmd.append("--nonet")
    if opts.list:
        cmd.append("-l")
    cmd.append(test)
    return cmd

def run(opts):
    # Build the list of tests we'll parallellize and the ones we'll run serially
    test_loader = unittest.TestLoader()
    parallel_tests = []
    serial_tests = []
    test_id = 1
    for filename in glob.glob(os.path.join(os.path.dirname(__file__), "check-*")):
        name = check_valid(filename)
        if not name or not os.path.isfile(filename):
            continue
        loader = importlib.machinery.SourceFileLoader(name, filename)
        module = importlib.util.module_from_spec(importlib.util.spec_from_loader(loader.name, loader))
        loader.exec_module(module)
        for test_suite in test_loader.loadTestsFromModule(module):
            for test in test_suite:
                test_method = getattr(test.__class__, test._testMethodName)
                test_str = "{0}.{1}".format(test.__class__.__name__, test._testMethodName)
                if opts.tests and not any([t in test_str for t in opts.tests]):
                    continue
                if getattr(test_method, "_testlib__non_destructive", False):
                    serial_tests.append(Test(test_id, build_command(filename, test_str, opts)))
                else:
                    parallel_tests.append(Test(test_id, build_command(filename, test_str, opts)))
                test_id += 1

    print("1..{0}".format(len(parallel_tests) + len(serial_tests)))
    sys.stdout.flush()

    if serial_tests:
        testlib.MachineCase.get_global_machine()
    for test in serial_tests:
        test.command.insert(-2, "--machine")
        test.command.insert(-2, "{0}:{1}".format(testlib.MachineCase.get_global_machine().ssh_address,
                                                 testlib.MachineCase.get_global_machine().ssh_port))
        test.command.insert(-2, "--browser")
        test.command.insert(-2, "{0}:{1}".format(testlib.MachineCase.get_global_machine().web_address,
                                                 testlib.MachineCase.get_global_machine().web_port))

    running_tests = []
    serial_test = None
    while serial_tests or parallel_tests or running_tests:
        if len(running_tests) < opts.jobs:
            if serial_tests and serial_test is None:
                test = serial_tests.pop(0)
                test.process = subprocess.Popen(test.command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                fcntl.fcntl(test.process.stdout.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)
                running_tests.append(test)
                serial_test = test
            elif parallel_tests:
                test = parallel_tests.pop(0)
                test.process = subprocess.Popen(test.command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                fcntl.fcntl(test.process.stdout.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)
                running_tests.append(test)

        for test in running_tests.copy():
            if test.process.poll() is not None:
                running_tests.remove(test)
                retry = finish_test(opts, test)

                # run again if needed
                if retry and test is serial_test:
                    serial_tests.insert(0, test)
                    test.output = b""
                elif retry:
                    parallel_tests.insert(0, test)
                    test.output = b""

                if test is serial_test:
                    serial_test = None
                else:
                    test.output += test.process.stdout.read()

        # Wait if we're at maximum number of threads or waiting for the serial_tests to finish
        if len(running_tests) == opts.jobs or (not parallel_tests and serial_tests):
            for test in running_tests:
                try:
                    test.process.wait(1 / opts.jobs)
                except subprocess.TimeoutExpired:
                    pass

    testlib.MachineCase.kill_global_machine()
    return 0


def main():
    parser = testlib.arg_parser()
    parser.add_argument('--publish', action='store', help="Unused")
    parser.add_argument('-j', '--jobs', dest="jobs", type=int,
                        default=os.environ.get("TEST_JOBS", 1), help="Number of concurrent jobs")
    opts = parser.parse_args()

    if opts.sit and opts.jobs > 1:
        parser.error("the -s or --sit argument not avalible with multiple jobs")

    image = testvm.DEFAULT_IMAGE
    revision = os.environ.get("TEST_REVISION")
    test_browser = os.environ.get("TEST_BROWSER", "chromium")
    if not revision:
        revision = subprocess.check_output(["git", "rev-parse", "HEAD"],
                                           universal_newlines=True).strip()

    # Tell any subprocesses what we are testing
    os.environ["TEST_REVISION"] = revision
    os.environ["TEST_BROWSER"] = test_browser
    testvm.DEFAULT_IMAGE = image
    os.environ["TEST_OS"] = image

    return run(opts)


if __name__ == '__main__':
    sys.exit(main())
