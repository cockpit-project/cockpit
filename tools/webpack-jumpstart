#!/bin/sh

# Download pre-built webpack for current git SHA from GitHub

# These are produced by .github/workflows/build-dist.yml for every PR and push.
# This is a lot faster than having to npm install and run webpack.

# Returns 0 when successful, 1 in case of an error, or 2 in case the cache
# entry couldn't be found (but might be available after waiting a bit longer).

GITHUB_REPO='cockpit-dist'
SUBDIR='dist'

export V="${V-0}"

set -eu
cd "$(realpath -m "$0"/../..)"
. tools/git-utils.sh

wait=''
rebase=''
while [ $# != 0 ] ; do
    case "$1" in
        --wait)
            wait=1;;
        --rebase)
            rebase=1;;
        *)
            echo "usage: $0 [--rebase] [--wait]" >&2
            exit 1
    esac
    shift
done

[ -n "${quiet}" ] || set -x

if [ -e dist ]; then
    echo "jumpstart: dist/ already exists, skipping" >&2
    exit 1
fi

if [ "${NODE_ENV-}" = "development" ]; then
    echo 'jumpstart: only works with production builds (NODE_ENV != development)' >&2
    exit 1
fi

# Here we find "base commit": the commit in our local tree which is equal to
# the HEAD of the PR at the time the jumpstart was built.  This might not be
# the commit that the jumpstart was actually built against (in case the PR
# wasn't fully-rebased and GitHub merged some commits from main).
# --rebase helps us deal with those situations.
#
# For example:
#
#              a---b---H                     (PR head)
#             /        |\
#            /       --M \---N               (GitHub PR merge commits)
#           /       /       /
#   ---o---o---o---m---o---n                 (origin/main)
#                   \
#                    a'--b'--H'              (rebased result)
#
# We might be run from H, M, or N.
#
# Someone has proposed a PR with three commits ('a', 'b', and head 'H'),
# branched off of main, which had two additional commits (up to head 'm') at
# the time of the jumpstart build.  GitHub will have created merge commit 'M'
# for the jumpstart build, but it will be marked with the tag `sha-H` so that
# it's possible for us to find it.  The jumpstart bundle will have a note of
# commit `m` in the contained `merge-base` file so that we can reconstruct the
# tree state of `M` for ourselves.  That's the idea of `--rebase`: we will
# rebase, adding commits a', b', and H' on top of m.  Assuming merging and
# rebasing produced the same result (which it almost always does), the tree
# state of H' will be exactly the same as M.
#
# We might also be asked to run against the merge commit ('M') itself, or a new
# merge commit ('N') in case main received additional commits.  In either case,
# the best thing we can do in either case is to back up to the original head
# 'H' and rebase onto 'm' from there, as above.

if [ -n "$(git status --porcelain)" ]; then
    echo 'Refusing operation on an unclean tree' >&2
    echo
    git status >&2
    exit 1
fi
# If we are rebasing and the HEAD commit is a merge, reset to the
# merged commit before proceeding.
if test -n "${rebase}" && git rev-parse --verify HEAD^2 >/dev/null; then
    git reset --hard HEAD^2
fi
tag="sha-$(git rev-parse HEAD)"

for try in $(seq 50 -1 0); do
    if fetch_to_cache tag "${tag}"; then
        break
    fi
    if [ -z "${wait}" -o "$try" = '0' ]; then
        echo "There is no cache entry ${tag}" >&2
        exit 1
    fi
    message WAIT 30s
    sleep 30s
done

if [ -n "${rebase}" ]; then
    merge_base="$(cat_from_cache "${tag}" merge-base)"
    # If we don't already have that commit, we'll need to go fetch it
    if ! git rev-list --quiet --objects "${merge_base}"; then
        message FETCH ".  [${merge_base}]"
        git fetch --no-write-fetch-head origin "${merge_base}"
    fi
    git rebase -- "${merge_base}"
fi

target_tree="$(cat_from_cache "${tag}" tree)"
if [ "$(git rev-parse HEAD^{tree})" != "${target_tree}" ]; then
    if [ -n "${rebase-}" ]; then
        echo "Internal error: even after rebase, don't have the correct tree" >&2
        exit 1
    else
        echo "The current working tree needs to be rebased: try --rebase" >&2
        exit 1
    fi
fi

tools/node-modules make_package_lock_json
unpack_from_cache "${tag}"
