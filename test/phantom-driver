#!/usr/bin/env phantomjs

/*
 * This file is part of Cockpit.
 *
 * Copyright (C) 2013 Red Hat, Inc.
 *
 * Cockpit is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * Cockpit is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.
 */

/* phantom-driver -- A small driver for phantomjs
 *
 * This program reads a line from stdin, executes the command
 * specified by it, and replies back with a line on stdout.
 *
 * The two main commands are "do" and "wait". "Do" will execute
 * arbitrary JavaScript in the context of the web page.  "Wait" will
 * run the event loop of the browser until the given condition is
 * true.
 *
 * The "wait" command will check the condition only at explicit
 * 'checkpoints'.  These checkpoints must be triggered by calling
 * 'phantom_checkpoint' from the webapp whenever it reaches a
 * interesting point.
 *
 * While phantom-driver is waiting for the next command, nothing
 * happens on the web page.  No websockets are served, no idle or
 * timeout handlers run, etc.  (The web page does not receive any
 * external input events in any case.)
 *
 * The rest of the command are: "open" to load a specified URL,
 * "inject" to load some JavaScript into the web page, "show" to take
 * a screenshot, and "keys" to send key events.
 */

var page = require('webpage').create();
var sys = require('system');

var onCheckpoint;
var lastError;
var waitTimeout;
var didTimeout;

function arm_timeout(timeout) {
    if (waitTimeout)
        return false;

    didTimeout = false;
    waitTimeout = setTimeout (function () {
        waitTimeout = null;
        didTimeout = true;
        if (onCheckpoint)
            onCheckpoint();
    }, timeout || 5000);
    return true;
}

function disarm_timeout() {
    if (!waitTimeout)
        return false;

    clearTimeout(waitTimeout);
    waitTimeout = null;
    didTimeout = false;
    return true;
}

page.viewportSize = { width: 800, height: 480 };

var canary = "phantom-canary" + -(Date());

function inject_basics() {
    var i, len;
    if (!page.evaluate(function(x) { return x in window; }, canary)) {
        for (i = 1, len = sys.args.length; i < len; i++) {
            page.injectJs(sys.args[i]);
            page.evaluate(function(x) {
                window.phantom_checkpoint = function() {
                    console.log("-*-CHECKPOINT-*-");
                };
                window[x] = x;
            }, canary);
        }
    }
}

var driver = {
    timeout: 60 * 1000,

    open: function(url) {
        var failure = null;

        page.onResourceError = function(ex) {
            failure = ex.errorString + " " + ex.url;
        };

        page.onLoadFinished = function(status) {
            page.onLoadFinished = null;
            page.onResourceError = null;
            if (status == "success")
                respond();
            else
                respond({ error: failure || status });
        };

	page.open(url);
    },

    reload: function() {
        this.expect_reload();
        page.reload();
    },

    expect_reload: function() {
        var failure = null;
        var res = null;
        var timer = null;

        function finish() {
            page.onResourceError = null;
            page.onLoadFinished = null;
            clearTimeout(wait);
            clearTimeout(timer);
            if (res === "success")
                respond();
            else
                respond({ error: res });
        }

        timer = setTimeout(function() {
            timer = null;
            res = "timeout";
            finish();
        }, this.timeout);

        page.onResourceError = function(ex) {
            failure = ex.errorString + " " + ex.url;
        };

        /*
         * HACK: phantomjs fires the page.onLoadFinished() handler
         * for each iframe, sometimes with the iframe triggering the
         * event first. This leads to race conditions.
         *
         * The only work around is to use a timeout.
         *
         * https://code.google.com/p/phantomjs/issues/detail?id=504
         */
        var wait = null;
        page.onLoadFinished = function(status) {
            if (status != "success" && failure)
                status = failure;
            failure = null;
            if (!res || res != "success")
                res = status;
            clearTimeout(wait);
            wait = setTimeout(function() {
                wait = null;
                finish();
            }, 200);
        };
    },

    switch_frame: function(name) {
        if (page.switchToFrame(name))
            respond();
        else
            respond({ error: "Can't switch to frame: " + name });
    },

    switch_top: function() {
        page.switchToMainFrame();
        respond();
    },

    show: function(file) {
        if (!file)
            file = "page.png"
        page.render(file);
        sys.stderr.writeLine("Wrote " + file)
        respond();
    },

    quit: function() {
        sys.stdout.writeLine(JSON.stringify({ result: true }));
        phantom.exit(0);
    },

    sit: function() {
        sys.stdout.writeLine(JSON.stringify({ result: true }));
        // fall through to the phantom event loop
    },

    eval: function(code) {
        lastError = null;
        inject_basics();
        var func = "function () { " + code + "}";
        try {
            var val = page.evaluate(func);
        } catch(ex) {
            respond({ error: String(ex) });
        }
        respond({ result: val });
    },

    wait: function(cond) {
        var func = "function () { return " + cond + "}";
        var local_timeout;

        function resp(out) {
            onCheckpoint = null;
            if (local_timeout)
                disarm_timeout();
            respond(out);
        }

        function check() {
            inject_basics();
            var val = page.evaluate(func);
            if (val) {
                if (didTimeout) {
                    sys.stderr.writeLine("WARNING: condition '" + cond +
                            "' was true after timeout, add some more checkpoints");
                }
                resp({ result: val });
            } else if (didTimeout) {
                resp ({ error: "timeout" });
            }
        }

        onCheckpoint = check;
        local_timeout = arm_timeout(this.timeout);
        check();
    },

    arm_timeout: function() {
        if (arm_timeout(this.timeout))
            respond({ result: true });
        else
            respond({ error: "timeout already armed" });
    },

    disarm_timeout: function() {
        if (disarm_timeout())
            respond({ result: true });
        else
            respond({ error: "no timeout armed" });
    },

    wait_checkpoint: function() {
        onCheckpoint = function () {
            onCheckpoint = null;
            if (didTimeout)
                respond({ error: "timeout" });
            else
                respond({ result: true });
        }
    },

    keys: function(type, keys, modifier) {
        var i;
        if (typeof keys == "string") {
            page.sendEvent(type, keys, null, null, modifier || 0);
        } else {
            for (i = 0; i < keys.length; i++) {
                var k = keys[i];
                if (typeof k == "string" && k.length > 1)
                    k = page.event.key[k];
                page.sendEvent(type, k, null, null, modifier || 0);
            }
        }
        respond();
    },

    upload_file: function(selector, file) {
        page.uploadFile(selector, file);
        respond();
    },

    ping: function() {
        respond({ result: "pong" });
    },
};

var first = true;

function respond(out) {
    if (!first) {
        if (lastError) {
            out = { error: lastError };
            lastError = null;
        } else if (arguments.length === 0) {
            out = { result: null };
        }
        sys.stdout.writeLine(JSON.stringify(out));
    }

    first = false;

    setTimeout(function() {
        var line = sys.stdin.readLine();

        if (line == "" && sys.stdin.atEnd()) {
            phantom.exit(0);
            return;
        }

        var cmd;
        try {
            cmd = JSON.parse(line);
        } catch(ex) {
            respond({ error: String(ex) });
            return;
        }

        if (onCheckpoint) {
            respond({ error: "assertion: onCheckpoint should be cleared in phantom-driver" });
        } else if (cmd.cmd in driver) {
            driver.timeout = cmd.timeout || driver.timeout;
            driver[cmd.cmd].apply(driver, cmd.args || args);
        } else {
            respond({ error: "No such method defined: " + cmd.cmd });
        }
    }, 0);
}

page.onConsoleMessage = function(msg, lineNum, sourceId) {
    if (msg == "-*-CHECKPOINT-*-") {
        // sys.stderr.writeLine("CHECKPOINT");
        if (onCheckpoint)
            onCheckpoint();
    } else
        sys.stderr.writeLine('> ' + msg);
};

page.onError = function(msg, trace) {
    var i;
    var backtrace = "";
    for (i = 0; i < trace.length; i++)
        backtrace += "\n" + trace[i].file + " " + trace[i].line + " " + trace[i].function;
    sys.stderr.writeLine("Page error: " + msg + backtrace);
    lastError = msg;
}

/* Get ready for message */
respond();
