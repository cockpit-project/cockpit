#!/usr/bin/python3

# This file is part of Cockpit.
#
# Copyright (C) 2016 Red Hat, Inc.
#
# Cockpit is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# Cockpit is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.

import parent
from testlib import *


@skipImage("kexec-tools not installed", "fedora-coreos", "debian-stable",
           "debian-testing", "ubuntu-2004", "ubuntu-stable")
@timeout(900)
@skipDistroPackage()
class TestKdump(MachineCase):

    def rreplace(self, s, old, new, count):
        li = s.rsplit(old, count)
        return new.join(li)

    def enableKdump(self):
        if self.machine.image in ["rhel-8-4", "rhel-8-5"]:
            # these images use BootLoaderSpec and grubenv
            self.sed_file('/^kernelopts=/ { s/crashkernel=[^ ]*//; s/$/ crashkernel=256M/; }', '/boot/grub2/grubenv')
        else:
            lines = self.machine.execute(command="cat /etc/default/grub", quiet=True).split("\n")
            lines = map(lambda line: self.rreplace(line, '"', ' crashkernel=256M"', 1)
                        if line.startswith("GRUB_CMDLINE_LINUX") else line, lines)
            self.machine.write("/etc/default/grub", "\n".join(lines))
            self.machine.execute("grub2-mkconfig -o /boot/grub2/grub.cfg")
        self.machine.execute("mkdir -p /var/crash")

    def enableLocalSsh(self):
        self.machine.execute("[ -f /root/.ssh/id_rsa ] || ssh-keygen -t rsa -N '' -f /root/.ssh/id_rsa")
        self.machine.execute("cat /root/.ssh/id_rsa.pub >> /root/.ssh/authorized_keys")
        self.machine.execute("ssh-keyscan -H localhost >> /root/.ssh/known_hosts")

    def rebootMachine(self):
        # Now reboot things
        self.machine.spawn("sync && sync && sync && sleep 0.1 && reboot", "reboot")
        self.machine.wait_reboot()
        self.machine.start_cockpit()
        self.browser.switch_to_top()
        self.browser.relogin("/kdump")

    def testBasic(self):
        b = self.browser
        m = self.machine

        b.wait_timeout(120)
        self.allow_restart_journal_messages()

        m.execute("systemctl enable kdump && systemctl start kdump || true")

        self.login_and_go("/kdump")

        b.wait_visible("#app")

        def assertActive(active):
            b.wait_visible(".pf-c-switch__input" + (active and ":checked" or ":not(:checked)"))

        if m.image.startswith("rhel-") or m.image in ["centos-8-stream"]:
            # some OSes have kdump enabled by default (crashkernel=auto)
            b.wait_in_text("#app", "Service is running")
            assertActive(True)
        else:
            # right now we have no memory reserved
            b.mouse("span + .popover-ct-kdump", "mouseenter")
            b.wait_in_text(".pf-c-tooltip", "No memory reserved.")
            b.mouse("span + .popover-ct-kdump", "mouseleave")
            # newer kdump.service have `ConditionKernelCommandLine=crashkernel` which fails gracefully
            unit = m.execute("systemctl cat kdump.service")
            if 'ConditionKernelCommandLine=crashkernel' in unit:
                # service should indicate that the unit is stopped
                b.wait_in_text("#app", "Service is stopped")
            else:
                # service should indicate an error
                b.wait_in_text("#app", "Service has an error")
            # ... and the button should be off
            assertActive(False)

        # there shouldn't be any crash reports in the target directory
        self.assertEqual(m.execute("find /var/crash -maxdepth 1 -mindepth 1 -type d"), "")

        self.enableKdump()
        self.rebootMachine()
        b.wait_visible("#app")
        self.enableLocalSsh()

        # minimal nfs validation
        settingsLink = "button:contains('locally in /var/crash')"

        b.click(settingsLink)
        b.set_val("#kdump-settings-location", "nfs")
        mountInput = "#kdump-settings-nfs-mount"
        b.set_input_text(mountInput, ":/var/crash")
        b.click("button{}:contains('Apply')".format(self.primary_btn_class))
        b.wait_visible("h4.pf-c-alert__title:contains('Unable to apply settings')")
        b.set_input_text(mountInput, "localhost:")
        b.click("button{}:contains('Apply')".format(self.primary_btn_class))
        b.wait_visible("h4.pf-c-alert__title:contains('Unable to apply settings')")
        b.click("button{}:contains('Apply')".format(self.primary_btn_class))

        # test compression
        b.click(settingsLink)
        b.click("#kdump-settings-compression")
        pathInput = "#kdump-settings-local-directory"
        b.click("button{}:contains('Apply')".format(self.primary_btn_class))
        b.wait_not_present(pathInput)
        m.execute("cat /etc/kdump.conf | grep -qE 'makedumpfile.*-c.*'")

        # generate a valid kdump config with ssh target
        b.click(settingsLink)
        b.set_val("#kdump-settings-location", "ssh")
        sshInput = "#kdump-settings-ssh-server"
        b.set_input_text(sshInput, "root@localhost")
        sshKeyInput = "#kdump-settings-ssh-key"
        b.set_input_text(sshKeyInput, "/root/.ssh/id_rsa")
        b.set_input_text(pathInput, "/var/crash")
        b.click("button{}:contains('Apply')".format(self.primary_btn_class))
        b.wait_not_present(pathInput)

        # we should have the amount of memory reserved that we indicated
        b.wait_in_text("#app", "256 MiB")
        # service should start up properly and the button should be on
        b.wait_in_text("#app", "Service is running")
        assertActive(True)
        b.wait_in_text("#app", "Service is running")

        # try to change the path to a directory that doesn't exist
        customPath = "/var/crash2"
        settingsLink = "button:contains('Remote over SSH')"
        b.click(settingsLink)
        b.set_val("#kdump-settings-location", "local")
        pathInput = "#kdump-settings-local-directory"
        b.set_input_text(pathInput, customPath)
        b.click("button{}:contains('Apply')".format(self.primary_btn_class))
        # we should get an error
        b.wait_visible("h4.pf-c-alert__title:contains('Unable to apply settings')")
        # also allow the journal message about failed touch
        self.allow_journal_messages(".*mktemp: failed to create file via template.*")
        # create the directory and try again
        m.execute("mkdir -p {0}".format(customPath))
        b.click("button{}:contains('Apply')".format(self.primary_btn_class))
        b.wait_not_present(pathInput)
        b.wait_visible("button:contains('locally in {0}')".format(customPath))

        # service has to restart after changing the config, wait for it to be running
        # otherwise the button to test will be disabled
        b.wait_in_text("#app", "Service is running")
        assertActive(True)

        # crash the kernel and make sure it wrote a report into the right directory
        b.click("button{}".format(self.default_btn_class))
        # we should get a warning dialog, confirm
        crashButton = "button{}:contains('Crash system')".format(self.danger_btn_class)
        b.click(crashButton)

        # wait until we've actuall triggered a crash
        b.wait_visible(".dialog-wait-ct")

        # wait for disconnect and then try connecting again
        b.switch_to_top()
        b.wait_in_text("div.curtains-ct h1", "Disconnected")
        m.disconnect()
        m.wait_boot(timeout_sec=300)
        self.assertNotEqual(m.execute(f"find '{customPath}' -maxdepth 1 -mindepth 1 -type d"), "")

    @nondestructive
    def testConfiguration(self):
        b = self.browser
        m = self.machine

        self.restore_file("/etc/kdump.conf")

        m.execute("systemctl disable --now kdump")

        self.login_and_go("/kdump")
        b.wait_visible("#app")

        # Check remote ssh location
        b.click("#kdump-change-target")
        b.wait_visible("#kdump-settings-dialog")
        b.set_val("#kdump-settings-location", "ssh")
        b.set_input_text("#kdump-settings-ssh-server", "admin@localhost")
        b.set_input_text("#kdump-settings-ssh-key", "/home/admin/.ssh/id_rsa")
        b.set_input_text("#kdump-settings-local-directory", "/var/tmp/crash")
        b.click("button:contains('Apply')")
        b.wait_not_present("#kdump-settings-dialog")
        conf = m.execute("cat /etc/kdump.conf")
        self.assertIn("path /var/tmp/crash", conf)
        self.assertIn("ssh admin@localhost", conf)
        self.assertIn("sshkey /home/admin/.ssh/id_rsa", conf)

        # Check remote NFS location
        b.click("#kdump-change-target")
        b.wait_visible("#kdump-settings-dialog")
        b.set_val("#kdump-settings-location", "nfs")
        b.set_input_text("#kdump-settings-nfs-mount", "localhost:/var/tmp/crash")
        b.click("button:contains('Apply')")
        b.wait_not_present("#kdump-settings-dialog")
        conf = m.execute("cat /etc/kdump.conf")
        self.assertIn("nfs localhost:/var/tmp/crash", conf)
        self.assertNotIn("path /var/tmp/crash", conf)
        self.assertNotIn("ssh admin@localhost", conf)
        self.assertNotIn("sshkey /home/admin/.ssh/id_rsa", conf)

        # Check local location
        b.click("#kdump-change-target")
        b.wait_visible("#kdump-settings-dialog")
        b.set_val("#kdump-settings-location", "local")
        b.set_input_text("#kdump-settings-local-directory", "/var/tmp")
        b.click("button:contains('Apply')")
        b.wait_not_present("#kdump-settings-dialog")
        conf = m.execute("cat /etc/kdump.conf")
        self.assertIn("path /var/tmp", conf)
        self.assertNotIn("nfs localhost:/var/tmp/crash", conf)

        # Check compression
        current = m.execute("grep '^core_collector' /etc/kdump.conf").strip()
        b.click("#kdump-change-target")
        b.wait_visible("#kdump-settings-dialog")
        b.set_checked("#kdump-settings-compression", True)
        b.click("button:contains('Apply')")
        b.wait_not_present("#kdump-settings-dialog")
        conf = m.execute("cat /etc/kdump.conf")
        self.assertIn(current + " -c", conf)


if __name__ == '__main__':
    test_main()
