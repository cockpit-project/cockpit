<!DOCTYPE html>
<!--
This file is part of Cockpit.

Copyright (C) 2014 Red Hat, Inc.

Cockpit is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

Cockpit is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Cockpit; If not, see <http://www.gnu.org/licenses/>.
-->
<html>
<head>
    <meta charset="utf-8">
    <title>Kubernetes tests</title>
    <link rel="stylesheet" href="../../tools/qunit.css" type="text/css" media="screen" />
    <script type="text/javascript" src="../../tools/qunit.js"></script>
    <script type="text/javascript" src="../base1/require.js"></script>
</head>
<body>
    <h1 id="qunit-header">Kubernetes tests</h1>
    <h2 id="qunit-banner"></h2>
    <div id="qunit-testrunner-toolbar"></div>
    <h2 id="qunit-userAgent"></h2>
    <ol id="qunit-tests"></ol>
    <div id="qunit-fixture">test markup, will be hidden</div>
    <div id="done-flag" style="display:none">Done</div>
<script>

/* -------------------------------------------------------------------------
 * The mock HTTP code should probably be moved into the base package once it
 * has been vetted, and there is another caller.
 */

function MockHttp(callback) {
    var self = this;

    function BasicError(problem) {
        this.problem = problem;
        this.message = problem;

        this.valueOf = function() {
            return this.problem;
        };
        this.toString = function() {
            return this.message;
        };
    }

    function HttpError(status, reason) {
        this.status = status;
        this.reason = reason;
        this.message = reason;
        this.problem = null;

        this.valueOf = function() {
            return this.status;
        };
        this.toString = function() {
            return this.status + " " + this.message;
        };
    }

    self.request = function request(req) {
        if (!req.path)
            req.path = "/";
        if (!req.method)
            req.method = "GET";
        if (req.params) {
            if (req.path.indexOf("?") === -1)
                req.path += "?" + $.param(req.params);
            else
                req.path += "&" + $.param(req.params);
        }
        delete req.params;

        if (!req.headers)
            delete req.headers;

        if (req.body !== undefined)
            ready();

        var ex = null;

        var dfd = $.Deferred();
        var responding = false;
        var output = "";
        var responsers = null;
        var streamer = null;
        var closed = false;

        req.mock_respond = function mock_respond(status, reason, headers, body) {
            if (dfd.state() != "pending")
                throw "Called req.mock_respond() on already completed request";
            responding = true;
            if (responsers)
                responsers.fire(status, headers || []);
            if (status < 200 || status > 299)
                dfd.reject(new HttpError(status, reason, body), body);
            else if (body !== undefined)
                req.mock_data(body, false);
        };

        req.mock_data = function mock_data(body, stream) {
            if (dfd.state() !== "pending") {
                if (closed)
                    return;
                throw "Called req.mock_data() on already completed request";
            }
            responding = true;
            if (typeof body !== "string")
                body = JSON.stringify(body);
            if (streamer)
                streamer(body);
            else
                output += body;
            if (!stream)
                dfd.resolve(output);
        };

        function ready() {
            window.setTimeout(function() {
                var ret = false;
                if (dfd.state() !== "pending")
                    return;
                if (callback)
                    ret = callback(req);
                if (ret === false)
                    req.mock_respond(404, "Not found: " + req.path, [], "Not found");
            }, 5);
        }

        var jpromise = dfd.promise;
        dfd.promise = function mypromise() {
            var ret = $.extend(jpromise.apply(this, arguments), {
                stream: function(callback) {
                    streamer = callback;
                    return this;
                },
                response: function(callback) {
                    if (responsers === null)
                        responsers = $.Callbacks("" /* no flags */);
                    responsers.add(callback);
                    return this;
                },
                input: function(message, stream) {
                    if (message !== null && message !== undefined) {
                        if (!req.body)
                            req.body = message;
                        else
                            req.body += message;
                    }
                    if (!stream)
                        ready();
                    return this;
                },
                close: function(problem) {
                    closed = true;
                    if (!problem)
                        problem = "disconnected";
                    dfd.reject(new BasicError(problem));
                    return this;
                },
                promise: this.promise
            });
            return ret;
        };

        return dfd.promise();
    };

    function find_header(headers, name) {
        if (!headers)
            return undefined;
        name = name.toLowerCase();
        for (var head in headers) {
            if (head.toLowerCase() == name)
                return headers[head];
        }
        return undefined;
    }

    self.post = function post(path, body, headers) {
        headers = headers || { };

        if ($.isPlainObject(body) || $.isArray(body)) {
            body = JSON.stringify(body);
            if (find_header(headers, "Content-Type") === undefined)
                headers["Content-Type"] = "application/json";
        } else if (body === undefined || body === null) {
            body = "";
        } else if (typeof body !== "string") {
            body = String(body);
        }

        return self.request({
            "method": "POST",
            "path": path,
            "body": body,
            "headers": headers
        });
    };

    self.get = function get(path, params, headers) {
        return self.request({
            "method": "GET",
            "params": params,
            "path": path,
            "body": "",
            "headers": headers
        });
    };
}

function deparam(query) {
  var parsed = { };
  var vars = query.split("&");
  for (var i = 0; i < vars.length; i++) {
      var pair = vars[i].split("=");
      var k = decodeURIComponent(pair[0]);
      var v = decodeURIComponent(pair[1]);
      if (typeof parsed[k] === "undefined" ||
          typeof parsed[k] === "function") {
          if (k.substr(k.length - 2) != '[]')
              parsed[k] = v;
          else
              parsed[k] = [v];
      } else if (typeof parsed[k] === "string") {
          parsed[k] = v;
      } else {
          parsed[k].push(v);
      }
  }

  return parsed;
}

/* -------------------------------------------------------------------------
 * A simple kubernetes data store
 *
 * We enumerate objects from here in our moke kube_apiserver() code below.
 * In addition there are various helper function for updating this and
 * triggering watches etc.
 */

var kube_last = 100;

var kude_data = { };

function guid() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
           s4() + '-' + s4() + s4() + s4();
}

function kube_update(key, item) {
    var type;
    if (!item) {
        if (kube_data[key]) {
            type = "DELETED";
            item = kube_data[key];
            delete kube_data[key];
        } else {
            return null;
        }
    } else {
        if (kube_data[key])
            type = "MODIFIED";
        else
            type = "ADDED";
        kube_data[key] = item;
    }

    if (!item.metadata)
        item.metadata = { };
    if (!item.metadata.uid)
        item.metadata.uid = guid();
    item.metadata.resourceVersion = kube_last;
    kube_last += 1;

    $(kube_data).triggerHandler("notify", [ type, key, item ]);
    return item;
}

function kube_apiserver(req) {
    var path;
    var query;

    var pos = req.path.indexOf('?');
    if (pos === -1) {
        path = req.path;
        query = { };
    } else {
        path = req.path.substring(0, pos);
        query = deparam(req.path.substring(pos + 1));
    }

    var parts = path.substring(1).split("/");

    /* The API check */
    if (parts.length == 1 && (parts[0] == "api" || parts[0] != "oapi")) {
        req.mock_respond(200, "OK", { }, JSON.stringify({
            versions: [ "v1" ]
        }));
        return true;
    }

    if (parts[0] != "api" && parts[0] != "oapi" && parts[1] != "v1")
        return false;

    base_uri = "/" + parts.slice(0, 2).join("/");
    parts = parts.slice(2);

    if (req.method === "POST") {
        return kube_api_post(req, parts, query, base_uri);
    } else if (req.method === "GET") {
        return kube_api_get(req, parts, query, base_uri);
    } else if (req.method === "DELETE") {
        return kube_api_delete(req, parts, query, base_uri);
    }  else {
        req.mock_respond(405, "Unsupported method");
        return true;
    }
}

function kube_api_get(req, parts, query, base_uri) {
    var resourceVersion = null;
    var namespace_re = ".+";

    /* Figure out if this is a watch */
    var watch = false;
    var what = parts.shift();
    if (what == "watch") {
        watch = true;
        what = parts.shift();
        if (query.resourceVersion) {
            resourceVersion = parseInt(query.resourceVersion, 10);
            if (isNaN(resourceVersion))
                throw "invalid resourceVersion";
        }
    }

    /* Figure out if namespace api was used */
    if (what == "namespaces" && parts.length > 1) {
        namespace_re = parts.shift();
        what = parts.shift();
    }

    var specific = parts.join("/");
    var kind = null;
    var regexp = null;

    function prepare(key, item) {
        if (resourceVersion) {
            if (!item.metadata || !item.metadata.resourceVersion ||
                item.metadata.resourceVersion < resourceVersion)
                return null;
        }
        if (specific) {
            if (key != specific)
                return null;
        }
        if (regexp) {
            if (!key.match(regexp))
                return null;
        }

        var copy = $.extend(true, { }, item);
        copy.selfLink = base_uri + "/" + key;
        copy.apiVersion = "v1";
        return copy;
    }

    /* Various lists */
    if (what == "namespaces") {
        regexp = /namespaces\/[a-zA-Z0-9-_]+$/;
        kind = "NamespaceList";
    } else if (what == "nodes") {
        regexp = /nodes\//;
        kind = "NodeList";
    } else if (what == "pods") {
        regexp = RegExp("namespaces/"+ namespace_re +"/pods/");
        kind = "PodList";
    } else if (what == "services") {
        regexp = RegExp("namespaces/"+ namespace_re +"/services/");
        kind = "ServiceList";
    } else if (what == "replicationcontrollers") {
        regexp = RegExp("namespaces/"+ namespace_re +"/replicationcontrollers/");
        kind = "ReplicationControllerList";
    } else if (what == "events") {
        regexp = RegExp("namespaces/"+ namespace_re +"/events/");
        kind = "EventList";
    } else if (what == "images") {
        req.mock_respond(404, "OK", { "Content-Type": "text/plain; charset=utf-8" });
        return;
    } else if (what == "imagestreams") {
        regexp = RegExp("namespaces/"+ namespace_re +"/imagestreams/");
        kind = "ImageStreamList";
    /* Nothing found */
    } else {
        return false;
    }

    function respond_get() {
        var items = [ ];
        var result = {
            kind: kind,
            creationTimestamp: null,
            items: items
        }

        $.each(kube_data, function(key, value) {
            var item = prepare(key, value);
            if (item)
                items.push(item);
        });

        req.mock_respond(200, "OK", { "Content-Type": "application/json" }, JSON.stringify(data));
    }

    function stream_watch(ex, type, key, value) {
        var item = prepare(key, value);
        if (item)
            req.mock_data(JSON.stringify({ type: type, object: item }) + "\n", true);
    }

    function respond_watch() {
        req.mock_respond(200, "OK", { "Content-Type": "text/plain; charset=utf-8" });

        $.each(kube_data, function(key, value) {
            var item = prepare(key, value);
            if (item)
                req.mock_data(JSON.stringify({ type: "ADDED", object: item }) + "\n", true);
        });

        $(kube_data).on("notify", stream_watch);

        window.setTimeout(function() {
            $(kube_data).off("notify", stream_watch);
            req.mock_data("", false);
        }, 5000);
    }

    if (watch)
        respond_watch();
    else
        respond_get();
}

function kube_api_post(req, parts, query, base_uri) {
    var namespace;
    var section;

    if (parts.length === 3) {
        if (parts[0] != "namespaces")
            return false;
        namespace = parts[1];
        section = parts[2];
    } else if (parts.length === 1) {
        section = parts[0];
    } else {
        return false;
    }

    var item;
    try {
        item = JSON.parse(req.body);
    } catch(ex) {
        req.mock_respond(400, "Bad JSON");
        return;
    }

    var kind = item.kind;
    var meta = item.metadata || { };
    var name = meta.name;

    if (!kind || !meta || !name) {
        req.mock_respond(400, "Bad fields in JSON");
        return;
    }

    if (kind.toLowerCase() + "s" != section) {
        req.mock_respond(400, "Bad section of URI");
        return;
    }

    parts.push(name);
    var key = parts.join("/");

    if (kube_data[key]) {
        req.mock_respond(409, "Already exists", { "Content-Type": "application/json" },
                         JSON.stringify({ code: 409, message: "Already exists" }));
        return;
    }

    kube_update(key, item);
    req.mock_respond(200, "OK", { "Content-Type": "application/json" }, JSON.stringify(item));
    return true;
}

function kube_api_delete(req, parts, query, base_uri) {
    var namespace;
    var kind;
    var name;

    if (parts.length === 4) {
        if (parts[0] != "namespaces")
            return false;
        namespace = parts[1];
        kind = parts[2];
        name = parts[3];
    } else if (parts.length === 2) {
        namespace = parts[1];
    } else {
        return false;
    }

    var key = parts.join("/");

    var resp = kube_update(key, null);
    req.mock_respond(200, "OK", { "Content-Type": "application/json" }, JSON.stringify(resp));
    return true;
}

function etcd_server(req) {
    if (req.path.indexOf("wait=true") !== -1) {
        /*
         * A wait request, for now just sit around and don't respond. This
         * is where we'll later mock etcd change notifications.
         */
        return;
    }

    return false;
}

/* -------------------------------------------------------------------------
 * The actual tests
 */

require([
    "jquery",
    "base1/cockpit",
    "kubernetes/client",
    "kubernetes/mock-basic",
    "kubernetes/mock-large"
], function($, cockpit, kubernetes, mock_basic, mock_large) {
    var cockpit_http = cockpit.http;
    cockpit.http = function(endpoint) {
        /* Our mock kubernetes apiserver */
        if (endpoint == 8080 || endpoint == 8443)
            return new MockHttp(kube_apiserver);

        /* For now etcd just returns not-found */
        else if (endpoint == 4001)
            return new MockHttp(etcd_server);

        /* Catch any other requests, fail test */
        else
            throw "Unexpected mock http endpoint " + endpoint;
    };

    /* A fresh set of kube_data for each test */
    QUnit.module("basic", {
        setup: function() {
            kube_data = $.extend(true, { }, mock_basic);
        }
    });

    test("singleton", function() {
        var client = kubernetes.k8client();
        var client2 = kubernetes.k8client();

        strictEqual(client, client2, "singleton returned same object");

        client2.close();

        var client3 = kubernetes.k8client();
        strictEqual(client, client3, "singleton returned same object after one closed");

        client.close();
        client3.close();

        var client4 = kubernetes.k8client();

        notStrictEqual(client, client4, "different object after all closed");
        client4.close();
    });

    asyncTest("list nodes", function() {
        expect(6);

        var client = kubernetes.k8client();
        client.watches.nodes.wait().always(function() {
            var nodes = client.select("Node");
            ok("Node:f530580d-a169-11e4-8651-10c37bdb8410" in nodes, "found node");
            var node = nodes["Node:f530580d-a169-11e4-8651-10c37bdb8410"];
            equal(node.metadata.name, "127.0.0.1", "localhost node");
            equal(typeof node.spec.capacity, "object", "node has resources");

            /* Check basic key behavior */
            equal(node.key, "Node:f530580d-a169-11e4-8651-10c37bdb8410", "key is set correctly");

            /* Key should not be encoded as JSON */
            var parsed = JSON.parse(JSON.stringify(node));
            ok(!("key" in parsed), "key should not be serialized")
            strictEqual(parsed.key, undefined, "key not be undefined after serialize");

            client.close();
            start();
        });
    });

    asyncTest("list pods", function() {
        expect(3);

        var client = kubernetes.k8client();
        client.watches.pods.wait().always(function() {
            var pods = client.select("Pod");
            equal(pods.items.length, 3, "number of pods");
            var pod = pods["Pod:11768037-ab8a-11e4-9a7c-080027300d85"];
            equal(typeof pod, "object", "found pod")
            equal(pod.metadata.labels.name, "apache", "pod has label");

            client.close();
            start();
        });
    });

    asyncTest("set namespace", function() {
        expect(4);
        var added = 0;
        var removed = 0;

        var client = kubernetes.k8client();
        client.watches.pods.wait().always(function() {
            var pods = client.select("Pod");
            client.track(pods);
            equal(pods.items.length, 3, "number of pods");
            $(pods).on("removed", function(ev, item) {
                removed++;
                if (removed == 2) {
                    equal(pods.items.length, 1, "number of other pods");
                    var pod = pods["Pod:9f1a316f-4db6-11e5-971a-525400e58104"];
                    equal(typeof pod, "object", "found pod");
                    client.namespace(null);
                }
            });

            $(pods).on("added", function(ev, item) {
                if (removed == 2)
                    added++;

                if (added == 2) {
                    equal(pods.items.length, 3, "all pods back");
                    client.close();
                    start();
                }
            });
            client.namespace("other");
        });
    });

    asyncTest("add pod", function() {
        expect(7);

        var ready = false;
        var changed = false;

        var client = kubernetes.k8client();
        var pods = client.select("Pod");
        client.track(pods);

        client.watches.pods.wait().always(function() {
            ready = true;

            equal(pods.items.length, 3, "number of pods");
            equal(pods["Pod:11768037-ab8a-11e4-9a7c-080027300d85"].metadata.labels.name, "apache", "pod has label");

            kube_update("namespaces/default/pods/aardvark", {
                "kind": "Pod",
                "metadata": {
                    "name": "aardvark",
                    "uid": "22768037-ab8a-11e4-9a7c-080027300d85",
                    "namespace": "default",
                    "labels": {
                        "name": "aardvark"
                    },
                },
                "spec": {
                    "volumes": null,
                    "containers": [ ],
                    "imagePullPolicy": "IfNotPresent"
                }
            });
        });

        $(pods).on("added", function(ev, item) {
            if (!ready)
                return;

            equal(pods.items.length, 4, "added a pod");
            equal(pods["Pod:22768037-ab8a-11e4-9a7c-080027300d85"].metadata.labels.name,
                  "aardvark", "new pod present in items");
            ok(item === pods["Pod:22768037-ab8a-11e4-9a7c-080027300d85"], "passed right argument");
            equal(changed, false, "changed not yet");
        });

        $(pods).on("changed", function() {
            if (!ready)
                return;
            changed = true;
            ok(true, "changed also fired");
            client.close();
            start();
        });
    });

    asyncTest("update pod", function() {
        expect(7);

        var ready = false;
        var changed = false;

        var client = kubernetes.k8client();
        var pods = client.select("Pod");
        client.track(pods);

        client.watches.pods.wait().always(function() {
            ready = true;

            equal(pods.items.length, 3, "number of pods");
            equal(pods.items[1].metadata.labels.name, "apache", "pod has label");

            kube_update("namespaces/default/pods/apache", {
                "kind": "Pod",
                "metadata": {
                    "name": "apache",
                    "uid": "11768037-ab8a-11e4-9a7c-080027300d85",
                    "namespace": "default",
                    "labels": {
                        "name": "apachepooo"
                    },
                }
            });
        });

        $(pods).on("updated", function(ev, item) {
            if (!ready)
                return;

            equal(pods.items.length, 3, "updated, didn't add a pod");
            equal(pods.items[1].metadata.labels.name, "apachepooo", "pod name updated");
            ok(item === pods.items[1], "passed right argument");
            equal(changed, false, "changed not yet");
        });

        $(pods).on("changed", function() {
            if (!ready)
                return;
            changed = true;
            ok(true, "changed also fired");
            client.close();
            start();
        });
    });

    asyncTest("remove pod", function() {
        expect(7);

        var ready = false;
        var changed = false;

        var client = kubernetes.k8client();
        var pods = client.select("Pod");
        client.track(pods);

        client.watches.pods.wait().always(function() {
            ready = true;

            equal(pods.items.length, 3, "number of pods");
            equal(pods.items[1].metadata.labels.name, "apache", "pod has label");

            kube_update("namespaces/default/pods/apache", null);
        });

        $(pods).on("removed", function(ev, item) {
            if (!ready)
                return;

            equal(pods.items.length, 2, "removed a pod");
            equal(pods.items[0].metadata.labels.name, "wordpressreplica", "right pod got removed");
            equal(item.metadata.labels.name, "apache", "passed right argument");
            equal(changed, false, "changed not yet");
        });

        $(pods).on("changed", function(ev, item) {
            if (!ready)
                return;
            changed = true;
            ok(true, "changed also fired");
            client.close();
            start();
        });
    });

    asyncTest("list services", function() {
        expect(3);

        var client = kubernetes.k8client();

        client.watches.services.wait().always(function() {
            var services = client.select("Service");
            var svc = services.items[0];
            equal(services.items.length, 2, "number of services");
            equal(svc.metadata.name, "kubernetes", "service id");
            equal(svc.spec.selector.component, "apiserver", "service has label");

            client.close();
            start();
        });
    });

    test("close immediate", function() {
        var client = kubernetes.k8client();
        deepEqual(client.objects, { }, "no objects yet");

        /* No error should be thrown on immediate close*/
        client.close();
    });

    var create_items = [
        {
            "kind": "Pod",
            "apiVersion": "v1",
            "metadata": {
                "name": "pod1",
                "uid": "d072fb85-f70e-11e4-b829-10c37bdb8410",
                "resourceVersion": "634203",
                "labels": {
                    "name": "pod1"
                    },
            },
            "spec": {
                "volumes": null,
                "containers": [{
                    "name": "database",
                    "image": "mysql",
                    "ports": [{ "containerPort": 3306, "protocol": "TCP" }],
                }],
                "nodeName": "127.0.0.1"
            }
        },{
            "kind": "Node",
            "apiVersion": "v1",
            "metadata": {
                "name": "node1",
                "uid": "6e51438e-d161-11e4-acbc-10c37bdb8410",
                "resourceVersion": "634539",
            },
            "spec": {
                "externalID": "172.2.3.1"
            }
        }
    ];

    asyncTest("create", function() {
        expect(6);

        var client = kubernetes.k8client();

        client.create(create_items, "namespace1")
            .done(function() {
                equal(kube_data["namespaces/namespace1/pods/pod1"].metadata.name, "pod1", "pod created");
                equal(kube_data["nodes/node1"].metadata.name, "node1", "node created");
                equal(kube_data["namespaces/namespace1"].metadata.name, "namespace1", "namespace created");

                equal(client.objects["Pod:d072fb85-f70e-11e4-b829-10c37bdb8410"].metadata.name,
                      "pod1", "pod object");
                equal(client.objects["Node:6e51438e-d161-11e4-acbc-10c37bdb8410"].metadata.name,
                      "node1", "node object");
            })
            .always(function() {
                equal(this.state(), "resolved", "succeeded");
                client.close();
                start();
            });
    });

    asyncTest("create namespace exists", function() {
        expect(7);

        var client = kubernetes.k8client();

        var namespace_item = {
            "apiVersion" : "v1",
            "kind" : "Namespace",
            "metadata" : { "name": "namespace1" }
        };

        client.create(namespace_item)
            .always(function() {
                    equal(this.state(), "resolved", "namespace succeeded");
                    equal(kube_data["namespaces/namespace1"].metadata.name, "namespace1", "namespace created");

                    client.create(create_items, "namespace1")
                        .done(function() {
                            equal(kube_data["namespaces/namespace1/pods/pod1"].metadata.name, "pod1",
                                  "pod created");
                            equal(kube_data["nodes/node1"].metadata.name, "node1", "node created");

                            equal(client.objects["Pod:d072fb85-f70e-11e4-b829-10c37bdb8410"].metadata.name,
                                  "pod1", "pod object");
                            equal(client.objects["Node:6e51438e-d161-11e4-acbc-10c37bdb8410"].metadata.name,
                                  "node1", "node object");
                        })
                        .always(function() {
                            equal(this.state(), "resolved", "succeeded");

                            client.close();
                            start();
                        });
            });
    });

    asyncTest("create namespace default", function() {
        expect(5);

        var client = kubernetes.k8client();

        client.create(create_items)
            .done(function() {
                equal(kube_data["namespaces/default/pods/pod1"].metadata.name, "pod1", "pod created");
                equal(kube_data["nodes/node1"].metadata.name, "node1", "node created");

                equal(client.objects["Pod:d072fb85-f70e-11e4-b829-10c37bdb8410"].metadata.name,
                      "pod1", "pod object");
                equal(client.objects["Node:6e51438e-d161-11e4-acbc-10c37bdb8410"].metadata.name,
                      "node1", "node object");
            })
            .always(function() {
                equal(this.state(), "resolved", "succeeded");

                client.close();
                start();
            });
    });

    asyncTest("create object exists", function() {
        expect(3);

        var client = kubernetes.k8client();

        var items = create_items.slice();
        items.push(items[0]);

        client.create(items, "namespace1")
            .fail(function(ex, response) {
                equal(ex.status, 409, "http already exists");
                equal(response.code, 409, "kubernetes already exists");
            })
            .always(function() {
                equal(this.state(), "rejected", "failed");

                client.close();
                start();
            });
    });

    var create_mixed = [
        {
            "kind": "Node", "apiVersion": "v1",
            "metadata": { "name": "node1", "uid": "f072fb85-f70e-11e4-b829-10c37bdb8410" },
            "spec": { "test": "test" }
        }, {
            "kind": "Service", "apiVersion": "v1",
            "metadata": { "name": "service2", "uid": "eeeefb85-f70e-11e4-b829-10c37bdb8410" },
            "spec": { "test2": "test2" }
        }, {
            "kind": "ReplicationController", "apiVersion": "v1",
            "metadata": { "name": "replicooo", "uid": "1111fb85-f70e-11e4-b829-10c37bdb8410" },
            "spec": { "test": "test" }
        }, {
            "kind": "Pod", "apiVersion": "v1",
            "metadata": { "name": "pod1", "uid": "d072fb85-f70e-11e4-b829-10c37bdb8410" },
            "spec": { "blah": "blah" }
        },{
            "kind": "Service", "apiVersion": "v1",
            "metadata": { "name": "service1", "uid": "e072fb85-f70e-11e4-b829-10c37bdb8410" },
            "spec": { "test": "test" }
        }
    ];

    asyncTest("create sort", function() {
        expect(2);

        var client = kubernetes.k8client();

        client.watches.pods.wait().always(function() {
            var items = client.select();
            client.track(items);

            var added = [];
            var count = 0;

            $(items).on("added", function(ev, item) {
                added.push(item.kind);

                count += 1;
                if (count == 4) {
                    deepEqual(added, [ "Namespace", "Service", "Service", "Pod" ], "added right order");
                } else if (count == 6) {
                    client.close();
                    start();
                }
            });

            client.create(create_mixed, "namespace1")
                .always(function() {
                    equal(this.state(), "resolved", "succeeded");
                });
        });
    });

    asyncTest("delete pod", function() {
        expect(7);

        var client = kubernetes.k8client();
        var pods = client.select("Pod");
        client.track(pods);

        client.create(create_items, "namespace2")
            .done(function() {
                equal(kube_data["namespaces/namespace2/pods/pod1"].metadata.name, "pod1", "pod created");
                equal(kube_data["nodes/node1"].metadata.name, "node1", "node created");
                equal(kube_data["namespaces/namespace2"].metadata.name, "namespace2", "namespace created");

                equal(client.objects["Pod:d072fb85-f70e-11e4-b829-10c37bdb8410"].metadata.name,
                      "pod1", "pod object");
                equal(client.objects["Node:6e51438e-d161-11e4-acbc-10c37bdb8410"].metadata.name,
                      "node1", "node object");

                client.remove("/api/v1/namespaces/namespace2/pods/pod1")
                    .done(function(){
                        client.watches.pods.wait().always(function() {
                            for (var i = pods.items.length - 1; i >= 0; i--) {
                                if(pods.items[i].metadata.labels.name === "pod1") {
                                    equal(pods.items[i].metadata.labels.name, "pod1", "right pod got removed");
                                    return;
                                }
                            };
                        });
                    });
            })
            .always(function() {
                equal(this.state(), "resolved", "succeeded");
                client.close();
                start();
            });
    });


    QUnit.module("large", {
        setup: function() {
            kube_data = $.extend(true, { }, mock_basic, mock_large);
        }
    });

    function has_unique_uids(items) {
        var i, seen = { };
        for (i = 0; i < items.items.length; i++) {
            if (seen[items.items[i].metadata.uid])
                return false;
            seen[items.items[i].metadata.uid] = items[i];
        }
        return true;
    }

    asyncTest("lookup", function() {
        var expected = {
            "apiVersion": "v1",
            "kind": "ReplicationController",
            "metadata": { "labels": { "example": "mock", "name": "3controller" },
                "name": "3controller",
                "resourceVersion": 10000,
                "uid": "11768037-ab8a-11e4-9a7c-100001001",
                "namespace": "default"
            },
            "selfLink": "/api/v1/namespaces/default/replicationcontrollers/3controller",
            "spec": { "replicas": 1, "selector": { "factor3": "yes" } }
        };

        var client = kubernetes.k8client();
        client.watches.pods.wait().always(function() {

            /* Get the item */
            var item = client.lookup("ReplicationController", "3controller", "default");
            deepEqual(item, expected, "correct item");

            /* The same item, without namespace */
            item = client.lookup("ReplicationController", "3controller");
            deepEqual(item, expected, "selected without namespace");

            /* Any replication controller */
            item = client.lookup("ReplicationController");
            equal(item.kind, "ReplicationController", "any replication controller");

            /* Shouldn't match */
            item = client.lookup("BadKind", "3controller", "default");
            strictEqual(item, null, "mismatch kind");
            item = client.lookup("ReplicationController", "badcontroller", "default");
            strictEqual(item, null, "mismatch name");
            item = client.lookup("ReplicationController", "3controller", "baddefault");
            strictEqual(item, null, "mismatch namespace");

            client.close();
            start();
        });
    });


    asyncTest("select", function() {
        var client = kubernetes.k8client();
        client.watches.pods.wait().always(function() {

            /* Select everything odd, 500 pods */
            var results = client.select(null, "default", { "type": "odd" });
            equal(results.items.length, 500, "correct amount");
            ok(has_unique_uids(results), "unique objects");

            /* Select everything odd, but wrong namespace, no pods */
            var results = client.select(null, "other", { "type": "odd" });
            equal(results.items.length, 0, "other namespace no pods");

            /* The same ones selected even when a second (present) label */
            results = client.select(null, "default", { "type": "odd", "tag": "silly"  });
            equal(results.items.length, 500, "with additional label");
            ok(has_unique_uids(results), "unique objects with additional label");

            /* Nothing selected when additional invalid field */
            results = client.select(null, "default", { "type": "odd", "tag": "billy"  });
            equal(results.items.length, 0, "no objects");

            /* Limit by kind */
            var results = client.select("Pod", "default", { "type": "odd" });
            equal(results.items.length, 500, "by kind");
            ok(has_unique_uids(results), "unique objects by kind");

            /* Limit by invalid kind */
            var results = client.select("Ood", "default", { "type": "odd" });
            equal(results.items.length, 0, "nothing for invalid kind");

            /* Everything selected when no selector */
            results = client.select(null, "default");
            equal(results.items.length, 1006, "all objects");

            /* Everything selected when no selector */
            results = client.select("Pod", "default", null);
            equal(results.items.length, 1002, "all pods");

            /* Nothing selected when bad namespace */
            results = client.select(null, "bad");
            equal(results.items.length, 0, "bad namespace no objects");

            /* Get the node when a null namespace */
            results = client.select(null, null);
            equal(results.items.length, 1008, "without namespace");

            /* Get the node when a null namespace */
            results = client.select(null, null);
            equal(results.items.length, 1008, "without namespace");

            /* Nothing selected when empty selector */
            results = client.select(null, "default", { });
            equal(results.items.length, 0, "namespace objects");

            client.close();
            start();
        });
    });

    asyncTest("infer", function() {
        var client = kubernetes.k8client();
        client.watches.pods.wait().always(function() {

            /* Start simple, exactly the labels selector matches */
            var results = client.infer(null, "default", { "tag": "silly", "type": "odd" });
            equal(results.items.length, 1, "selected replication controller");
            equal(results.items[0].metadata.name, "oddcontroller", "got oddcontroller");

            /* Other namespace, no match */
            var results = client.infer(null, "other", { "tag": "silly", "type": "odd" });
            equal(results.items.length, 0, "selected no controller");

            /* Now with extra labels, as you'd usually see it */
            results = client.infer(null, "default", { "tag": "silly", "type": "odd", "another": "value" });
            equal(results.items.length, 1, "selected controller with extra labels");
            equal(results.items[0].metadata.name, "oddcontroller", "got oddcontroller with extra labels");

            /* Make two replication controllers match */
            results = client.infer(null, "default", { "tag":"silly", "type":"odd", "another":"value", "factor3":"yes" });
            equal(results.items.length, 2, "two replication controllers");
            equal(results.items[0].metadata.name, "oddcontroller", "got oddcontroller in set");
            equal(results.items[1].metadata.name, "3controller", "got 3controller in set");

            /* Everything inferred when no labels */
            results = client.infer(null, "default", null);
            equal(results.items.length, 4, "all objects with selectors");

            /* Everything inferred when no labels */
            results = client.infer("ReplicationController", "default");
            equal(results.items.length, 2, "all replication controllers with selectors");

            /* Nothing when wrong namespace */
            results = client.infer(null, "other");
            equal(results.items.length, 0, "no objects with other namespace");

            /* Nothing inferred when empty label */
            results = client.infer(null, "default", { });
            equal(results.items.length, 0, "no objects");

            client.close();
            start();
        });
    });

    asyncTest("hosting", function() {
        var client = kubernetes.k8client();
        client.watches.pods.wait().always(function() {

            /* Find out which pods this node is hosting */
            var results = client.hosting("Pod", "127.0.0.1");
            equal(results.items.length, 1, "selected hosted pods");
            equal(results.items[0].metadata.name, "wordpress", "got wordpress pod");

            client.close();
            start();
        });
    });



    asyncTest("list images", function() {
        expect(3);

        var client = kubernetes.k8client();
        equal(client.watches.images, undefined, "no image watcher");
        client.include("images");
        notEqual(client.watches.images, undefined, "watcher created");
        client.watches.images.wait().always(function() {
            var images = client.select("Image");
            equal(images.items.length, 0, "number of images");
            client.close();
            start();
        });
    });

    asyncTest("list imagestreams", function() {
        expect(3);

        var client = kubernetes.k8client();
        client.include("imagestreams");
        client.watches.imagestreams.wait().always(function() {
            var streams = client.select("ImageStream");
            equal(streams.items.length, 1, "number of imagestreams");
            var stream = streams["ImageStream:c216455b-4cc5-11e5-8a7f-0e5582eacc27"];
            equal(typeof stream, "object", "found imagestream")
            equal(stream.metadata.name, "mock-image-stream", "imagestream name");
            client.close();
            start();
        });
    });

    QUnit.start();
});
</script>
</body>
</html>
