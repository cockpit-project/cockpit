#!/bin/bash
# run static code checks like pyflakes and pycodestyle

set -eu

# we consider any function named test_* to be a test case
# each test is considered to succeed if it exits with no output
# exit with status 77 is a skip, with the message in the output
# otherwise, any output is a failure, even if exit status is 0

#
# pyflakes
#
test_pyflakes_pkg_tools() {
    python3 -m pyflakes /dev/null || skip
    python3 -m pyflakes tools/build-debian-copyright tools/npm-release-time
}

# TODO: there are currently a lot of pyflakes errors like
#   'parent' imported but unused
#   'from testlib import *' used; unable to detect undefined names
# Filter these out until these get fixed properly.
test_pyflakes_test() {
    python3 -m pyflakes /dev/null || skip
    filter="(unable to detect undefined names|defined from star imports|'parent' imported but unused)"
    ! python3 -m pyflakes test/ 2>&1 | grep -Ev "${filter}"
}

#
# wrongly marked translatable strings
#
test_js_translatable_strings() {
    ! git grep -n -E "(gettext|_)\(['\`]" -- {src,pkg}/'*'.{js,jsx}
}

test_no_translatable_attr() {
    ! git grep -n 'translatable=["'\'']yes' -- pkg doc
}

#
# Unsafe content-security-policy
#
# It's dangerous to have 'unsafe-inline' or 'unsafe-eval' in our
# content-security-policy entries. This is the browser equivalent
# of setenforce 0
test_unsafe_security_policy() {
    git grep -lIz -E 'content-security-policy.*(\*|unsafe)' 'pkg/*/manifest.json' | while read -d '' filename; do
        if test ! -f "$(dirname ${filename})/content-security-policy.override"; then
            echo "${filename} contains unsafe content security policy"
        fi
    done
}

#
# Bad paths or modifications in patternfly for fonts
#
test_patternfly_font_paths() {
    test -d dist || skip 'dist/ not built'
    ! grep --color=auto -H -n "\.\./fonts/OpenSans\|fonts/.*eot\|truetype" -r dist
}

# Valid JSON files
test_json_verify() {
    git ls-files -z '*.json' | while read -d '' filename; do
        python3 -m json.tool "${filename}" /dev/null 2>&1 | sed "s@^@${filename}: @"
    done
}

# pycodestyle python syntax check
test_pycodestyle() {
    python3 -m pycodestyle /dev/null || skip
    PYFILES="$(git grep --cached -lI '^#!.*python3') $(git ls-files -c '*.py')"
    python3 -m pycodestyle --max-line-length=415 --ignore W504 $PYFILES
}

test_node_modules_freshness() {
    tools/node-modules test_static_code
}

# every C file should #include "config.h" at the top
test_include_config_h() {
    # every C file should #include "config.h" at the top
    git ls-files -cz '*.c' | while read -d '' filename; do
        if sed -n '/^#include "config.h"$/q1; /^\s*#/q;' "${filename}"; then
            printf '%s: #include "config.h" is not the first line\n' "${filename}"
        fi
    done
}

### end of tests.  start of machinery.

skip() {
    printf "%s" "$*"
    exit 77
}

main() {
    cd "$(realpath -m "$0/../..")"
    if [ ! -e .git ]; then
        echo '1..0 # SKIP not in a git checkout'
        exit 0
    fi

    exit_status=0
    counter=0

    tests=($(compgen -A function 'test_'))
    printf "1..%d\n" "${#tests[@]}"


    for test_function in ${tests[@]}; do
        path="/static-code/$(echo ${test_function} | tr '_' '-')"
        counter=$((counter + 1))
        fail=''
        skip=''

        # run the test, capturing its output and exit status
        output="$(${test_function} 2>&1)" && test_status=0 || test_status=$?

        if [ "${test_status}" = 77 ]; then
            skip=" # SKIP ${output}"
            output=''
        elif [ "${test_status}" != 0 -o -n "${output}" ]; then
            exit_status=1
            fail=1
        fi

        # excluding the plan, this is the only output that we ever generate
        printf "%s %d %s%s\n" "${fail:+not }ok" "${counter}" "${path}" "${skip}"
        if [ -n "${output}" ]; then
            printf "%s\n" "${output}" | sed -e 's/^/# /'
        fi
    done

    exit "${exit_status}"
}

main
