<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
	"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<refentry id="api-cockpit">
  <refmeta>
    <refentrytitle>cockpit.js</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>cockpit.js</refname>
    <refpurpose>Basic cockpit API to interact with the system</refpurpose>
  </refnamediv>

  <refsection>
    <title>Loading cockpit.js</title>
    <para><code>cockpit.js</code> should be loaded via a script tag. In general jQuery should
      be loaded before <code>cockpit.js</code> as in the example below. If jQuery is not loaded
      then only the <link linkend="cockpit-channels">raw channel API</link> will be defined.</para>

<programlisting><![CDATA[
<script src="../base1/jquery.js">
<script src="../base1/cockpit.js">
]]></programlisting>
  </refsection>

  <refsection>
    <title>User Login</title>

    <refsection id="cockpit-logout">
      <title>cockpit.logout()</title>
<programlisting>
cockpit.logout([reload])
</programlisting>
      <para>Logout of Cockpit. Unless <code>reload</code> is <code>false</code> this will also
        cause the page to be reloaded, so that the user can see the logged out state.</para>
    </refsection>

    <refsection id="cockpit-user">
      <title>cockpit.user</title>
<programlisting>
cockpit.user["user"]
cockpit.user["name"]
cockpit.user["groups"]
cockpit.user["shell"]
cockpit.user["home"]
cockpit.user["id"]
</programlisting>
      <para>This object contains information about the user that's currently logged into cockpit.
        The following fields are defined:</para>

      <variablelist>
        <varlistentry>
          <term><code>"groups"</code></term>
          <listitem><para>This is an array of group names to which the user belongs.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"home"</code></term>
          <listitem><para>This is user's home directory.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"id"</code></term>
          <listitem><para>This is unix user id.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"name"</code></term>
          <listitem><para>This is a readable name for the user.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"shell"</code></term>
          <listitem><para>This is unix user shell.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"user"</code></term>
          <listitem><para>This is the unix user like <code>"root"</code>.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>The fields will be <code>undefined</code> until a connection is made to the
        cockpit server.</para>
    </refsection>

    <refsection id="cockpit-info-changed">
      <title>cockpit.user.onchanged</title>
<programlisting>
$(cockpit.user).on("changed", function() { ... })
</programlisting>
      <para>This event is fired when the user info changes or first becomes available.</para>
    </refsection>

  </refsection>

  <refsection id="cockpit-location">
    <title>Page Location</title>

<programlisting>
location = cockpit.location
cockpit.location = "/path"
</programlisting>

    <para>Cockpit components often have different views, without changing the HTML file that is
      being viewed. These are known as pages. <code>cockpit.location</code> is an object that can
      be used to read the current page and to navigate to a different page location. It works by
      updating <code>window.location.hash</code>.</para>

    <para>The <code>cockpit.location</code> looks like a HTTP path with a possible query
      string:</para>

<programlisting>
/path/sub/page?option=value,option2
</programlisting>

    <para>The <link linkend="cockpit-location-path"><code>location.path</code></link> and
      <link linkend="cockpit-location-options"><code>location.options</code></link> contain a parsed
      form of the location. While the location cannot be modified in place, a new one can be
      created by assigning a string to <code>cockpit.location</code> or by calling the
      <link linkend="cockpit-location-go"><code>location.go()</code></link> function.</para>

    <para><code>cockpit.location</code> is designed similarly to <code>window.location</code>
      in that the location object is preplaced whenever the current page location changes. To be
      aware of when the page location changes listen for the
      <link linkend="cockpit-location-changed"><code>cockpit.onlocationchanged</code></link>
      event.</para>

    <para>Using the location object as a string will result in the
      <link linkend="cockpit-location-href"><code>location.href</code></link>.</para>

    <refsection id="cockpit-location-href">
      <title>location.href</title>
      <para>The string representation of this page location, including any options.</para>
    </refsection>

    <refsection id="cockpit-location-path">
      <title>location.path</title>
      <para>An array of path segments, parsed and decoded appropriately. An empty array denotes
        the root path.</para>
    </refsection>

    <refsection id="cockpit-location-options">
      <title>location.options</title>
      <para>A javascript object containing the various options present in the location.</para>
    </refsection>

    <refsection id="cockpit-location-go">
      <title>location.go()</title>
<programlisting>
location.go(path, [options])
</programlisting>
      <para>Changes the current location to the given <code>path</code> and <code>options</code>.
        If the <code>path</code> argument is a string, it will be parsed into a path. If it is
        a relative path, then the result will be relative to the current <code>location.path</code>.
        If the <code>path</code> argument is an array of path segments, it will be treated as a
        full parsed absolute path.</para>

      <para>Any options found in a <code>path</code> will be added to those in the optional
        <code>options</code> argument, and used in the result.</para>

      <para>The location change will only take effect if the location has not changed in the
        meantime. This can be to good effect by saving a <code>cockpit.location</code> object
        and doing a conditional navigation, by calling the saved <code>location.go()</code>
        method later. This will only navigate if the user or other code has not navigated in
        the meantime.</para>
    </refsection>

    <refsection id="cockpit-location-replace">
      <title>location.replace()</title>
<programlisting>
location.replace(path, [options])
</programlisting>
      <para>Similar to <link linkend="cockpit-location-go"><code>location.go()</code></link>
        except the location change will not result in a navigation change in the browser's
        history.</para>
    </refsection>

    <refsection id="cockpit-location-decode">
      <title>location.decode()</title>
<programlisting>
path = location.decode(href, [options])
</programlisting>
      <para>Decode a cockpit href into its <code>path</code> array. If the <code>options</code>
        argument is specified, then it will be populated with options found in the href.</para>

      <para>If href is a relative path it will be resolved relative to
        <code>location.href</code>.</para>
    </refsection>

    <refsection id="cockpit-location-encode">
      <title>location.encode()</title>
<programlisting>
href = location.encode(path, [options])
</programlisting>
      <para>Encode the given <code>path</code> and <code>options</code> into a cockpit href.
        The <code>path</code> argument may be an array of path segments, or a string path. If
        a relative path is passed, it will be resolved relative to <code>location.href</code>.</para>
    </refsection>

    <refsection id="cockpit-location-changed">
      <title>cockpit.onlocationchanged</title>
<programlisting>
$(cockpit).on("locationchanged", function() { ... })
</programlisting>
      <para>An event emitted when over the <code>cockpit.location</code> changes. Typically a
        component reacts to this event by updating its interface to reflect the new
        <link linkend="cockpit-location-path"><code>cockpit.location.path</code></link> and
        <link linkend="cockpit-location-options"><code>cockpit.location.options</code></link>.</para>

      <para>This event is not triggered immediately during a <code>location.go()</code> or
        similar call. It will be triggered asynchronously at a later time.</para>
    </refsection>
  </refsection>

  <refsection id="cockpit-jump">
    <title>Jumping between components</title>

<programlisting>
cockpit.jump("/system/log")
</programlisting>

    <para>In Cockpit in there multiple components shown. In order to tell Cockpit to jump to and show
      another component and a certain location within that component, use the
      <code>cockpit.jump()</code> function. Stable component paths are documented. Don't assume
      you can navigate into paths that are not stable API.</para>

    <refsection id="cockpit-jump-jump">
      <title>cockpit.jump()</title>
<programlisting>
cockpit.jump(path, [ host ])
</programlisting>
      <para>Ask Cockpit to jump to another component. The location of the current component will
        not be affected. The <code>path</code> argument can be a string path, starting with <code>/</code>
        or an array containing the parts of a path that will be joined to create a path. If <code>host</code>
        is not specified, then the component on the same host as the caller will be displayed. If
        host is null, then the host portion of the path will be removed, displaying the component on
        the host that cockpit is connected directly to. This is mostly useful for displaying a
        dashboard or other multi-machine components.</para>
      <para>If the calling component is not running within Cockpit, or the calling component is not
        currently displayed, then the jump will not happen, and this function has no effect.</para>
    </refsection>

  </refsection>

  <refsection id="cockpit-spawn">
    <title>Spawning Processes</title>

    <para>This is the API for spawning a process and receiving its output, as well
      as exit codes.</para>

    <refsection id="cockpit-spawn-spawn">
      <title>cockpit.spawn()</title>
<programlisting>
process = cockpit.spawn(args, [options])
</programlisting>

      <para>Spawns a process on the system.</para>

      <para>The <code>args</code> should be an array starting with the executable and
        containing all the arguments to pass on the command line. If <code>args</code>
        is a string then it is interpreted as an executable name. The optional
        <code>options</code> argument is a javascript plain object and can contain
        any of the following fields:
      </para>

      <variablelist>
        <varlistentry>
          <term><code>"binary"</code></term>
          <listitem><para>If set to <code>true</code> then handle the input and output
            of the process as arrays of binary bytes.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"directory"</code></term>
          <listitem><para>The directory to spawn the process in.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"err"</code></term>
          <listitem><para>Controls where the standard error is sent. By default it is logged
            to the journal. If set to <code>"out"</code> it is included in with the
            output data. If set to <code>"ignore"</code> then the error output is discarded.
            If set to <code>"message"</code>, then it will be returned as the error message.
            When the <code>"pty"</code> field is set, this field has no effect.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"host"</code></term>
          <listitem><para>The remote host to spawn the process on. If no host is specified
            then the correct one will be automatically selected based on the page
            calling this function.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"environ"</code></term>
          <listitem><para>An optional array that contains strings to be used as
            additional environment variables for the new process. These are
            <code>"NAME=VALUE"</code> strings.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"pty"</code></term>
          <listitem><para>Launch the process in its own PTY terminal, and send/receive
            terminal input and output.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"batch"</code></term>
          <listitem><para>Batch data coming from the process in blocks of at least this
              size. This is not a guarantee. After a short timeout the data will be sent
              even if the data doesn't match the batch size. Defaults to zero.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"latency"</code></term>
          <listitem><para> The timeout for flushing any cached data in milliseconds.</para></listitem>
        </varlistentry>
	<varlistentry>
	  <term><code>"superuser"</code></term>
          <listitem><para>Set to <code>"require"</code> to spawn the process as root instead of
              the logged in user. If the currently logged in user is not permitted to become root
              (eg: via <code>pkexec</code>) then the <code>client</code> will immediately be
  	      <link linkend="cockpit-dbus-onclose">closed</link> with a <code>"access-denied"</code>
              problem code.</para>
          <para>Set to <code>"try"</code> to try to run the process as root, but if that fails,
              fall back to an unprivileged process.</para></listitem>
	</varlistentry>
      </variablelist>

      <para>The spawned process is a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete if the process exits successfully, or fail if there's a problem.
        Some additional methods besides the standard jQuery promise methods are documented
        below.</para>

      <para>The standard output of the process is made available via the spawned process
        object. Any non-UTF8 output from the process will be coerced into textual form.
        It is highly recommended that only textual output be produced by the command.
        The standard error is logged to the journal.</para>
    </refsection>

    <refsection id="cockpit-spawn-script">
      <title>cockpit.script()</title>
<programlisting>
process = cockpit.script(script, [args], [options])
</programlisting>

      <para>Run a shell script on the system.</para>

      <para>This function <link linkend="cockpit-spawn-spawn">spawns</link> a Bourne shell script
        process. The full text of the <code>/bin/sh</code> shell script should be passed in as
        the first argument. The <code>args</code> can be an array of arguments, not including
        the executable, which are passed to the script as <code>$1</code>, <code>$2</code> and
        so on. Shebang options are not used or respected.</para>

      <para>The <code>options</code> is an optional javascript plain object and can include
        any of the fields listed for the
        <link linkend="cockpit-spawn-spawn"><code>cockpit.spawn()</code></link> function.</para>

      <para>The spawned process is a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete if the script exits successfully, or fail if there's a problem.
        Some additional methods besides the standard jQuery promise methods are documented
        below.</para>

      <para>The standard output of the process is made available via the spawned process
        object. Any non-UTF8 output from the process will be coerced into textual form.
        It is highly recommended that only textual output be produced by the command.
        The standard error is logged to the journal by default.</para>
    </refsection>

    <refsection id="cockpit-spawn-done">
      <title>process.done()</title>
<programlisting>
process.done(function(data[, message]) { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        method. It sets up a handler to be called when the process finishes successfully.</para>
      <para>The <code>data</code> argument contains the standard output of the process.
        If it a string, unless the process was opened in binary mode, in which case the
        <code>data</code> is an array of bytes. If a
        <code><link linkend="cockpit-spawn-stream">process.stream()</link></code>
        handler is set up, then any standard output data consumed by the handler will not
        be included in the <code>data</code> argument.</para>
      <para>If the process was spawned with the <code>"err"</code> option set to
        <code>"message"</code> then the second argument will contain the standard error
        output of the process.</para>
    </refsection>

    <refsection id="cockpit-spawn-fail">
      <title>process.fail()</title>
<programlisting>
process.fail(function(exception[, data]) { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink> method.
        It sets up a handler to be called when the process fails, terminates or exits.</para>

      <para>The <code>exception</code> object passed to the handler can have the
        following fields:</para>

      <variablelist>
        <varlistentry>
          <term><code>message</code></term>
          <listitem><para>A message describing the exception. If the process was spawned with
              the <code>"err"</code> option set to <code>"message"</code> then the second argument
              will contain the standard error output of the process.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>problem</code></term>
          <listitem><para>A <link linkend="cockpit-problems">problem code</link> string when
            a problem occurred starting or communicating with the process. This is <code>null</code>
            if the process exited or was terminated.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>exit_status</code></term>
          <listitem><para>The numeric exit status of the process. This is <code>null</code> if
            the process did not exit.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>exit_signal</code></term>
          <listitem><para>A string representing a unix signal that caused the process to terminate.
            This is <code>null</code> if the process did not terminate because of a signal.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>If the process actually ran and produced output before failing, it will be available in
        the <code>data</code> argument. Otherwise this argument will be <code>undefined</code>.</para>
    </refsection>

    <refsection id="cockpit-spawn-always">
      <title>process.always()</title>
<programlisting>
process.always(function() { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink> method.
        It sets up a handler to be called when when the process completes, whether it exits successfully,
        fails, terminates, or exits with a failure.</para>
    </refsection>

    <refsection id="cockpit-spawn-stream">
      <title>process.stream()</title>
<programlisting>
process.stream(function(data) { ... })
</programlisting>
      <para>This sets up a handler to be called when the process has standard output. The
        handler will be called multiple times. The handler will be called regardless of
        whether the process ends up exiting successfully or not.</para>
      <para>Only one handler may be registered at a time. Registering an additional handler
        replaces the previous one. The handler receives either string <code>data</code> or
        an array of binary bytes as its argument. A stream handler may return a number, which
        indicates the number of characters or bytes consumed from <code>data</code>. Any data
        not consumed will be included again the next time the handler is called.</para>
      <para>If a <code>process.stream()</code> handler is set up, then the
        <code><link linkend="cockpit-spawn-done">process.done()</link></code> handlers will
        only get any remaining data not consumed by the stream handler.</para>
    </refsection>

    <refsection id="cockpit-spawn-input">
      <title>process.input()</title>
<programlisting>
process.input(data, [stream])
</programlisting>
      <para>This method writes <code>data</code> to the standard input of the process.
        If <code>data</code> is <code>null</code> or <code>undefined</code> it is not sent.
        The <code>data</code> should be a string or an array of bytes if the process was
        opened in binary mode.</para>
      <para>If <code>stream</code> is set to <code>true</code> then this function may be
        called again with further input. Otherwise the standard input of the process
        is closed.</para>
    </refsection>

    <refsection id="cockpit-spawn-close">
      <title>process.close()</title>
<programlisting>
process.close([problem])
</programlisting>
      <para>Close the process. If <code>problem</code> is specified it should be a
        standard <link linkend="cockpit-problems">problem code</link> string. In this case the
        process will be terminated with a signal.</para>
    </refsection>
  </refsection>

  <refsection id="cockpit-problems">
    <title>Problem Codes</title>
    <para>Cockpit represents problems with standardized problem string codes.</para>
    <variablelist>
      <varlistentry>
        <term><code>"access-denied"</code></term>
        <listitem><para>The user is not permitted to perform the action in question.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"authentication-failed"</code></term>
        <listitem><para>User authentication failed.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"internal-error"</code></term>
        <listitem><para>An unexpected internal error without further info. This should
          not happen during the normal course of operations.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"no-cockpit"</code></term>
        <listitem><para>The system does not have a compatible version of Cockpit installed
          or installed properly.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"no-session"</code></term>
        <listitem><para>Cockpit is not logged in.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"not-found"</code></term>
        <listitem><para>Something specifically requested was not found, such as a file,
          executable etc.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"terminated"</code></term>
        <listitem><para>Something was terminated forcibly, such as a connection, process
          session, etc.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"timeout"</code></term>
        <listitem><para>Something timed out.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"unknown-hostkey"</code></term>
        <listitem><para>The remote host had an unexpected or unknown key.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"no-forwarding"</code></term>
        <listitem><para>Could not forward authentication credentials to the remote host.</para></listitem>
      </varlistentry>
    </variablelist>

    <refsection id="cockpit-messages">
      <title>cockpit.message()</title>
<programlisting>
message = cockpit.message(problem)
message = cockpit.message(exception)
</programlisting>
      <para>Return a message for the <code>exception</code> or <code>problem</code> code
        passed as an argument. If the argument is an object with a <code>"message"</code> property,
        as is the case with most exceptions, that will be returned directly. If the argument is
        an object with a <code>"problem"</code> property, then it will be used as the problem code.
        An appropriate message will be returned for problem codes.</para>
    </refsection>

  </refsection>

  <refsection id="cockpit-dbus">
    <title>DBus Access</title>

    <para>Cockpit allows access to DBus services via this API.</para>

    <para>DBus values are represented as javascript values and objects as follows:</para>

    <variablelist>
      <varlistentry>
        <term><code>BYTE 'y'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>BOOLEAN 'b'</code></term>
        <listitem><para>Javascript boolean.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>INT16 'n'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>UINT16 'q'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>INT32 'i'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>UINT32 'u'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>INT64 'x'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>UINT64 't'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>DOUBLE 'd'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>STRING 's'</code></term>
        <listitem><para>Javascript string.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>OBJECT_PATH 'o'</code></term>
        <listitem><para>Javascript string.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>SIGNATURE 'g'</code></term>
        <listitem><para>Javascript string.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>ARRAY of BYTE 'ay'</code></term>
        <listitem><para>A string containing base64 encoded data.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>ARRAY of DICT_ENTRY with STRING keys 'a{s?}'</code></term>
        <listitem><para>A javascript plain object with the keys as property names.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>ARRAY of DICT_ENTRY with other keys 'a{??}'</code></term>
        <listitem><para>A javascript plain object each key JSON encoded into a string property name.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>ARRAY of other</code></term>
        <listitem><para>A javascript array.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>VARIANT</code></term>
        <listitem><para>A javascript plain object with the <code>"t"</code> property set to a DBus type string,
            and the <code>"v"</code> property set to a value.</para></listitem>
      </varlistentry>
    </variablelist>

    <refsection id="cockpit-dbus-dbus">
      <title>cockpit.dbus()</title>
<programlisting>
client = cockpit.dbus(name, [options])
</programlisting>

      <para>Create a DBus client for the given bus <code>name</code> (eg: service name). Use the
        following functions to make DBus method calls, watch for events, etc. The optional
        <code>options</code> argument is a javascript plain object, and may include:</para>

      <variablelist>
        <varlistentry>
          <term><code>"bus"</code></term>
          <listitem><para>The DBus bus to connect to. Specifying <code>"session"</code> will
              connect to the DBus user session bus, <code>"user"</code> will connect to the
              user bus (on some systems this is identical to the session bus), and <code>"system"</code>
              will connect to the DBus system bus. This defaults to "system" if not
              present.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"host"</code></term>
          <listitem><para>The host to open the channel to. If no host is specified
            then the correct one will be automatically selected based on the page
            calling this function.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"superuser"</code></term>
          <listitem><para>Set to <code>"require"</code> to talk to this service as root.
            The DBus service will see the DBus method calls and accesses as coming from root,
            rather than the logged in user. This is useful for talking to services that do not
            correctly use <ulink url="http://www.freedesktop.org/software/polkit">polkit</ulink>
            to authorize administrative users. If the currently logged in user is not
            permitted to become root (eg: via <code>pkexec</code>) then the <code>client</code> will
            immediately be <link linkend="cockpit-dbus-onclose">closed</link> with a
            <code>"access-denied"</code> problem code.</para>
          <para>Set to <code>"try"</code> to try to talk as root, but if that fails,
            fall back to unprivileged.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"track"</code></term>
          <listitem><para>It is valid for a DBus service to exit, and be restarted in such a
            way that clients continue to talk to it across the restart. Some services are not
            written with this in mind. If the <code>"track"</code> option is set to
            <code>true</code> then the channel will close when the service exits and/or disconnects
            from the DBus bus.</para></listitem>
        </varlistentry>
      </variablelist>
    </refsection>

    <refsection id="cockpit-dbus-close">
      <title>client.close()</title>
<programlisting>
client.close([problem])
</programlisting>
      <para>Close the DBus client. If <code>problem</code> is specified it should be a
        <link linkend="cockpit-problems">problem code</link> string.</para>
    </refsection>

    <refsection id="cockpit-dbus-onclose">
      <title>client.onclose</title>
<programlisting>
$(client).on("close", function(options) { ... })
</programlisting>
      <para>An event triggered when the DBus client closes. This can happen either because
        <link linkend="cockpit-dbus-close">client.close()</link> function was called,
        or the DBus service went away, or some other problem or disconnection.</para>
      <para>The <code>options</code> will contain various close information, including a
        <code>"problem"</code> field which will be set if the channel was closed because
        of a problem.</para>
    </refsection>

    <refsection id="cockpit-dbus-onowned">
      <title>client.onowner</title>
<programlisting>
$(client).on("owner", function(event, owner) { ... })
</programlisting>
      <para>An event triggered when the owner of the DBus name changes. The owner
        value will be the id of the name owner on the bus or null if the name
        is unowned. The absence of an owner should not be treated as a disconnection.
        However this makes it possible to take some action based on the
        actual status of the service, for example disconnecting a pending signal handler.</para>
    </refsection>

    <refsection id="cockpit-dbus-options">
      <title>client.options</title>
      <para>Set to the options used when creating the client. Will not change for the life of
        the client.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxy">
      <title>client.proxy</title>
<programlisting>
proxy = client.proxy([interface, path])
</programlisting>

      <para>Create proxy javascript object for a DBus <code>interface</code>. At the
        specified DBus object <code>path</code>. The proxy will have
        properties, methods and signals from to the DBus interface, and allows for
        natural interaction. If no <code>interface</code> is specified then the DBus
        bus name of the client is used. If no <code>path</code> is specified, then
        the DBus name of the client is converted to a path.</para>

      <para>If creating lots of proxies for a given <code>interface</code> it is more
        efficient to use the
        <link linkend="cockpit-dbus-proxies"><code>client.proxies()</code></link>
        function.</para>

      <para>The proxy is loaded when the
        <link linkend="cockpit-dbus-proxy-valid"><code>proxy.valid</code></link> field is
        <code>true</code>, and it is set to <code>false</code> if the underlying
        <code>interface</code> and/or <code>path</code> don't or no longer exist, or
        the <code>client</code> has closed. You can wait for proxy to become valid
        by passing a callback to its
        <link linkend="cockpit-dbus-proxy-wait"><code>proxy.wait()</code></link> function.
        The <link linkend="cockpit-dbus-proxy-onchanged"><code>proxy.onchanged</code></link>
        event will also fire when the proxy becomes valid or invalid. DBus properties and
        methods on the proxy are not defined until the proxy becomes valid.</para>

<programlisting>
value = proxy.Prop1
proxy.WritableProp = value
</programlisting>

      <para>All DBus properties on the <code>interface</code> that start with an upper case
        letter (as is convention) will be automatically defined on this proxy, and will update
        their values as the DBus property values change. In addition the
        <link linkend="cockpit-dbus-proxy-onchanged"><code>proxy.onchanged</code></link> event
        will fire every time the properties change.</para>

      <para>If you assign a value to a writable property on the proxy, the proxy will try to set
        that property on the DBus <code>interface</code> at <code>path</code>. The actual proxy
        property value will not update until the DBus service has notified the proxy of the
        change. If setting a property fails a warning will be logged. In order to have more
        reliable setting of properties, or track when they have been set, or if setting fails,
        use the <link linkend="cockpit-dbus-call"><code>client.call()</code></link> directly.
        It should be noted that DBus service implementations may also be inconsistent in
        their behavior when setting a property fails.</para>

      <para>You can access the raw property data using the
        <link linkend="cockpit-dbus-proxy-data"><code>proxy.data</code></link> field, including
        data for properties that do not start with an upper case letter.</para>

<programlisting>
proxy.Method(arg1, arg2)
    .done(function(retval1, retval2) {
       ...
    })
    .fail(function(ex) {
       ...
    });
</programlisting>
      <para>All DBus methods on the <code>interface</code> that start with an upper case
        letter (as is convention) will be automatically defined on this proxy. These
        methods are called with arguments as normal javascript arguments. A
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete successfully when the method returns, or fail if an error occurs.
        The return values from the DBus method will be passed to the <code>done</code> handler
        function directly.</para>

      <para>Methods that do not start with an upper case letter can be invoked by using
        the usual <link linkend="cockpit-dbus-proxy-call"><code>proxy.call()</code></link> directly.</para>

<programlisting>
$(proxy).on("Signal", function(event, arg1, arg2) {
    ...
});
</programlisting>

      <para>All DBus signals on the <code>interface</code> that start with an upper case
        letter (as is convention) will be automatically emit events on this proxy. These
        events will contain the signal arguments after the standard <code>event</code>
        argument.</para>

      <para>Signals that do not start with an upper case letter can be subscribed to by
        using <link linkend="cockpit-dbus-proxy-signal"><code>proxy.onsignal</code></link>
        directly.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxy-client">
      <title>proxy.client</title>
      <para>Set to the DBus client of the proxy. Will not change for the life of
        the proxy.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxy-path">
      <title>proxy.path</title>
      <para>Set to the DBus object path of the proxy. Will not change for the life of
        the proxy.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxy-iface">
      <title>proxy.iface</title>
      <para>Set to the DBus interface name of the proxy. Will not change for the life
        of the proxy.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxy-valid">
      <title>proxy.valid</title>
      <para>Set to <code>true</code> when the proxy's DBus interface is present at its
        DBus path, and all information for the proxy has loaded. Is set to <code>false</code>
        while loading, and after the proxy no longer refers a DBus interface and path.
        Also set to <code>false</code> if the <code>client</code> closes.</para>
      <para>Use the by <link linkend="cockpit-dbus-proxy-wait"><code>proxy.wait()</code></link>
        function to wait for a proxy to load. The
        <link linkend="cockpit-dbus-proxy-onchanged"><code>proxy.onchanged</code></link>
        event will also be emitted when the proxy becomes valid or invalid. DBus properties and
        methods on the proxy are not defined until the proxy becomes valid.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxy-data">
      <title>proxy.data</title>
      <para>A plain javascript object containing all the raw property data that this
        proxy has loaded. This will be updated automatically as the proxy is notified
        of property changes from the DBus service. The
        <link linkend="cockpit-dbus-proxy-onchanged"><code>proxy.onchanged</code></link>
        event will be emitted when it changes.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxy-call">
      <title>proxy.call()</title>
<programlisting>
invocation = proxy.call(method, args, [options])
</programlisting>
      <para>Make a DBus method call on this proxy.</para>

      <para>For DBus methods that start with an upper case letter, is usually more convenient
        <link linkend="cockpit-dbus-proxy">to call the method directly on the proxy</link>.
        However if methods that do not follow the usual DBus convention,
        or specify additional options, or the caller cannot be sure that the method actually
        exists, you can use this method.</para>

      <para>This function also works on proxies that have are still loading and have not
        become valid yet.</para>

      <para>The <code>method</code> should be a DBus method name, and the <code>args</code>
        should be an array of arguments to pass to the method. The <code>options</code>
        are <link linkend="cockpit-dbus-call">described elsewhere</link>.</para>

      <para>The returned value is identical to the one returned from
        <link linkend="cockpit-dbus-call">client.call()</link>. It is a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete successfully when the method returns, or fail if an error occurs.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxy-wait">
      <title>proxy.wait()</title>
<programlisting>
proxy.wait(function() {
   ...
});
</programlisting>
      <para>Wait for a proxy to finish loading, and invoke the callback function when ready.
        If this method is called after a proxy has already loaded, then the callback will
        be invoked immediately. Use <code>proxy.valid</code> to determine whether the proxy
        loading resulting in a valid proxy.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxy-onchanged">
      <title>proxy.onchanged</title>
<programlisting>
$(proxy).on("changed", function(data) {
   ...
});
</programlisting>
      <para>This event is emitted when the proxy's properties change.</para>

      <para>The <code>data</code> has the following form, and will only include
        properties that have changed:</para>

<programlisting>
{
   "Prop1": "value",
   "Prop2": 5
}
</programlisting>
    </refsection>

    <refsection id="cockpit-dbus-proxy-signal">
      <title>proxy.onsignal</title>
<programlisting>
$(proxy).on("signal", function(event, name, args) {
    ...
});
</programlisting>
      <para>This event is emitted when the proxy's emits an event.</para>

      <para>For most events, that have names which start with an upper case letter, you can
        just <link linkend="cockpit-dbus-proxy">connect to that event as a signal directly</link>.
        However if you wish to be notified when any signal is emitted, or for signals that do not
        follow the usual DBus convention, you can connect to this event.</para>

      <para>The <code>name</code> is the DBus signal name, and the <code>args</code> is an array
        of arguments that were emitted with the signal.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxies">
      <title>client.proxies</title>
<programlisting>
proxies = client.proxies([interface], [path_namespace])
</programlisting>

      <para>Create <link linkend="cockpit-dbus-proxy">proxy javascript objects</link> for
        a DBus interfaces. The proxies will have properties, methods and signals from
        the DBus <code>interface</code>, and allow for natural interaction. If no
        <code>interface</code> is specified then the DBus bus name of the client is used.
        If no <code>path_namespace</code> is provided then <code>"/"</code> will be used.</para>

      <para>Proxies will be automatically created for instances of the
        <code>interface</code> available at the DBus service. The optional
        <code>path_namespace</code> argument can be used to restrict the proxies for
        instances that have DBus paths which have the namespace path prefix.</para>

<programlisting>
proxy1 = proxies["/dbus/path1"];
proxy2 = proxies["/dbus/path2"];
for (proxy in proxies) {
    ...
}
</programlisting>
      <para>The returned <code>proxies</code> object will is used as a dictionary,
        and will have values containing proxies for DBus interface instances, with the
        keys being the DBus paths of those instances. It is possible to enumerate over
        the returned <code>proxies</code>.</para>

      <para>Proxies will be automatically added and removed from the <code>proxies</code>
        object as they appear and disappear in the service. The
        <link linkend="cockpit-dbus-proxies-onadded"><code>proxies.onadded</code></link>
        and <link linkend="cockpit-dbus-proxies-onremoved"><code>proxies.onremoved</code></link>
        events will be emitted. DBus services may not support notifications of paths
        disappearing.</para>

      <para>Use the <code>proxies.wait()</code> function to be notified when the initial
        set of proxies has been populated.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxies-wait">
      <title>proxies.wait()</title>
<programlisting>
proxies.wait(function() {
    ...
});
</programlisting>
      <para>Wait for a <code>proxies</code> object to populate its initial set of proxies.
        If this method is called after the proxies have populated, the callback will be
        invoked immediately.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxies-client">
      <title>proxies.client</title>
      <para>Set to the DBus client of the proxies. Will not change.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxies-iface">
      <title>proxies.iface</title>
      <para>Set to the DBus interface name of the proxies. Will not change.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxies-path_namespace">
      <title>proxies.path_namespace</title>
      <para>Set to the DBus path namespace used which the proxies must have as a DBus
        path prefix. Will not change.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxies-onadded">
      <title>proxies.onadded</title>
<programlisting>
$(proxies).on("added", function(event, proxy) {
    ...
})
</programlisting>
      <para>This event is emitted when a proxy is added to the <code>proxies</code> object.
        The proxy will already have loaded.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxies-onchanged">
      <title>proxies.onchanged</title>
<programlisting>
$(proxies).on("changed", function(event, proxy) {
    ...
})
</programlisting>
      <para>This event is emitted when one of the proxy in the <code>proxies</code> object
        changes its properties.</para>
    </refsection>

    <refsection id="cockpit-dbus-proxies-onremoved">
      <title>proxies.onremoved</title>
<programlisting>
$(proxies).on("removed", function(event, proxy) {
    ...
})
</programlisting>
      <para>This event is emitted when a proxy is removed to the <code>proxies</code> object.</para>
    </refsection>

    <refsection id="cockpit-dbus-call">
      <title>client.call()</title>
<programlisting>
invocation = client.call(path, interface, method, args, [options])
</programlisting>

      <para>Make a DBus method call.</para>

      <para>The <code>path</code> is the DBus object path to make
        the call on, <code>interface</code> is the DBus interface for the method and
        <code>method</code> is the name of the method to call. The <code>args</code> is an
        array of arguments to pass to the method, each of which must be appropriate for the
        expected <link linkend="cockpit-dbus">DBus type</link> of that argument. The
        <code>args</code> may be <code>null</code> if no arguments are to be sent.</para>

      <para>The returned value is a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete successfully when the method returns, or fail if an error occurs.</para>

      <para>If <code>options</code> is specified it should be a plain javascript object,
        which may contain the following properties:</para>

      <variablelist>
        <varlistentry>
          <term><code>flags</code></term>
          <listitem><para>A string containing DBus message flags. No flags are defined at
            this time.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>type</code></term>
          <listitem><para>A valid DBus type signature to use when calling the method. In the
              absence of this, the DBus service will be introspected (and the result cached) to
              ask what the method type signature is.</para></listitem>
        </varlistentry>
      </variablelist>
    </refsection>

    <refsection id="cockpit-dbus-done">
      <title>invocation.done()</title>
<programlisting>
invocation.done(function(args, options) { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        method. It sets up a handler to be called when the DBus method call finishes
        successfully.</para>
      <para>The <code>args</code> argument is an array of return values from the DBus method.
        Each of them will be converted to an appropriate
        <link linkend="cockpit-dbus">javascript type</link>.</para>
      <para>The <code>options</code> argument may contain additional information about the
        reply. If the <code>type</code> option was specified when performing the method call,
        then the <code>options</code> in the reply here will also contain a <code>type</code>
        field containing the DBus type signature of the output. If the <code>flags</code> option
        was specified when performing the call then the <code>options</code> in the reply here
        will contain message flags. Possible out message flags are:</para>

      <variablelist>
        <varlistentry>
          <term><code>&gt;</code></term>
          <listitem><para>A big endian message.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>&lt;</code></term>
          <listitem><para>A little endian message.</para></listitem>
        </varlistentry>
      </variablelist>

    </refsection>

    <refsection id="cockpit-dbus-fail">
      <title>invocation.fail()</title>
<programlisting>
invocation.fail(function(exception) { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink> method.
        It sets up a handler to be called when the DBus method call fails.</para>

      <para>The <code>exception</code> object passed to the handler can have the
        following properties:</para>

      <variablelist>
        <varlistentry>
          <term><code>problem</code></term>
          <listitem><para>A <link linkend="cockpit-problems">problem code</link> string when
              a problem occurred starting or communicating with the DBus service. This is
              <code>null</code> in the cases where an actual DBus error was occurred.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>name</code></term>
          <listitem><para>The DBus error name. This will be <code>null</code> in cases where the
            failure was not due to a DBus error.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>message</code></term>
          <listitem><para>A DBus error message. This will be <code>null</code> in cases where the
            failure was not due to a DBus error.</para></listitem>
        </varlistentry>
      </variablelist>
    </refsection>

    <refsection id="cockpit-dbus-always">
      <title>invocation.always()</title>
<programlisting>
invocation.always(function() { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink> method.
        It sets up a handler to be called when when the DBus method call finishes whether successfully,
        or fails.</para>
    </refsection>

    <refsection id="cockpit-dbus-subscribe">
      <title>client.subscribe()</title>
<programlisting>
subscription = client.subscribe(match, function(path, interface, signal, args) { ... })
</programlisting>
      <para>Subscribe to signals. The <code>match</code> argument is a javascript plain object which
        defines what signals to subscribe to. Each property in the <code>match</code> argument restricts
        signals subscribed to. If a property is not present then it is treated as a wildcard, matching
        anything. If an empty object is specified as <code>match</code> then all signals will be
        subscribed to. The <code>match</code> argument may contain the following properties:</para>

      <variablelist>
        <varlistentry>
          <term><code>interface</code></term>
          <listitem><para>A DBus interface to match.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>path</code></term>
          <listitem><para>A DBus object path to match. May not be used together with the
            <code>path_namespace</code> property. It should be a valid DBus object path,
            that is, it should have no trailing slash.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>path_namespace</code></term>
          <listitem><para>A DBus object path prefix to match. Any paths in the hierarchy below this
            top path will match. May not be used together with the <code>path</code>
            property.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>member</code></term>
          <listitem><para>The DBus signal name to match.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>arg0</code></term>
          <listitem><para>Matches the first argument of a DBus message, which must be a
             string.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>The handler passed as the second argument will be invoked when the signal is received.
        A <code>subscription</code> is returned which can be used to remove the subscription by
        calling its <code>subscription.remove()</code> method.</para>

      <para>It is not a problem to subscribe to the same signals more than once, with identical
        or slightly different <code>match</code> arguments.</para>
    </refsection>

    <refsection id="cockpit-dbus-remove">
      <title>subscription.remove()</title>
<programlisting>
subscription.remove()
</programlisting>

      <para>Unsubscribe from the DBus signal subscription.</para>
    </refsection>

    <refsection id="cockpit-dbus-watch">
      <title>client.watch</title>
<programlisting>
watch = client.watch(path)
watch = client.watch({ "path_namespace": path_namespace, "interface": interface })
</programlisting>
      <para>Watch for property and interface changes on the given DBus object
        <code>path</code> DBus <code>path_namespace</code>. If <code>interface</code> is
        specified only properties on that DBus interface will be watched.</para>

      <para>The <link linkend="cockpit-dbus-proxy"><code>client.proxy()</code></link> and
          <link linkend="cockpit-dbus-proxies"><code>client.proxies()</code></link> functions and
        the objects they return are high level wrappers around <code>client.watch()</code>.</para>

      <para>The property and interface changes will be available in raw form on the
        <link linkend="cockpit-dbus-onnotify"><code>client.onnotify</code></link> event.</para>

      <para>Property and interface changes that are caused by a method call or signal will
        show up before that method call reply is received, or signal event is triggered.
        It should be possible to rely on this guarantee, unless the DBus service in question
        behaves incorrectly. Internally these watches work well with code that implements the
        <ulink url="http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager">ObjectManager</ulink>
        portion of the DBus specification. If no ObjectManager implementation is available, the
        watch falls back to using DBus
        <ulink url="http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-introspectable">Introspection</ulink> along with the usual
        <ulink url="http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties">PropertiesChanged</ulink> signal. If the DBus service implements none of these, or implements them in an
        inconsistent manner, then this function will provide inconsistent or unexpected
        results.</para>

      <para>The parameter is either a DBus <code>path</code> or a plain javascript object
        with zero or more of the following fields. If an empty javascript object is used as
        an argument, then all paths, interfaces and properties will be watched.</para>

      <variablelist>
        <varlistentry>
          <term><code>interface</code></term>
          <listitem><para>Watch properties on this DBus interface.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>path</code></term>
          <listitem><para>Watch interfaces and properties at this DBus path. May not be
              used together with the <code>path_namespace</code> property.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>path_namespace</code></term>
          <listitem><para>Watch interfaces and properties under this DBus path. It should
              be a valid DBus object path, that is, it should have no trailing slash.
              If an ObjectManager implementation is available at this interface, then it
              is used. May not be used together with the <code>path</code> property.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>The returned value is a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete successfully when the watch has populated its initial set of properties
        and interfaces, and these have been notified via
        <link linkend="cockpit-dbus-onnotify"><code>client.onnotify</code></link>.</para>

      <para>A watch can be removed by calling the
        <link linkend="cockpit-dbus-watch-remove"><code>watch.remove()</code></link> method on
        the returned value. If identical watches are added more than once, then they must
        also be removed the same number of times before the removal takes effect.</para>
    </refsection>

    <refsection id="cockpit-dbus-watch-done">
      <title>watch.done()</title>
<programlisting>
watch.done(function() { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        method. It sets up a handler to be called when the watch has populated its initial
        properties and interfaces.</para>
    </refsection>

    <refsection id="cockpit-dbus-watch-fail">
      <title>watch.fail()</title>
<programlisting>
watch.fail(function() { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        method. It sets up a handler to be called if the watch fails to populate its initial
        properties and interfaces. Note that a watch will only fail if the DBus client
        closes or is somehow disconnected. It does not fail in the case of missing
        interfaces or properties.</para>
    </refsection>

    <refsection id="cockpit-dbus-watch-always">
      <title>watch.always()</title>
<programlisting>
watch.always(function() { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        method. It sets up a handler to be called when the watch has populated its initial
        properties and interfaces or has failed to do so.</para>
    </refsection>

    <refsection id="cockpit-dbus-watch-remove">
      <title>watch.remove()</title>
<programlisting>
watch.remove()
</programlisting>
      <para>Remove the watch. This may not have any immediate effect if other watches are in
        place. In particular, if identical watches are added more than once, then they must
        also be removed the same number of times before the removal takes effect.</para>
    </refsection>

    <refsection id="cockpit-dbus-onnotify">
      <title>client.onnotify</title>
<programlisting>
$(client).on("notify", function(data) { ... })
</programlisting>
      <para>An event triggered when
        <link linkend="cockpit-dbus-watch">watched</link> properties or interfaces change.</para>

      <para>The <link linkend="cockpit-dbus-proxy"><code>client.proxy()</code></link> and
          <link linkend="cockpit-dbus-proxies"><code>client.proxies()</code></link> functions and
          the objects they return are high level wrappers around the <code>data</code> provided
          by this event.</para>

      <para>The <code>data</code> has the following form:</para>

<programlisting>
{
    "/path1": {
        "org.Interface1": {
            "Prop1": "value",
            "Prop2": 5
        },
        "org.Interface2": null
    }
}
</programlisting>

      <para>Multiple paths may be present, each of which may have multiple interfaces, each
        of which may have multiple properties. The first time a given path and interface is
        emitted from this signal, it will have all its properties and interfaces. Thereafter
        only changes are noted. If an interface is set to <code>null</code>, then that
        interface has disappeared.</para>
    </refsection>

    <refsection id="cockpit-dbus-notify">
      <title>client.notify</title>
<programlisting>
client.notify(data)
</programlisting>
    <para>Emits a synthetic <link
    linkend="cockpit-dbus-onnotify"><code>notify</code></link> event.
    The <code>data</code> argument should follow the same layout as
    described for the <code>notify</code> event.</para>
    </refsection>

    <refsection id="cockpit-dbus-variant">
      <title>cockpit.variant()</title>
<programlisting>
variant = cockpit.variant(type, value)
</programlisting>

      <para>A DBus variant is represented as a plain javascript object with a
        <code>"t"</code> property represesting the full DBus type of the variant,
        and a <code>"v"</code> property containing the variant value.</para>

      <para>This is a helper function for creating such a variant object.</para>
    </refsection>

    <refsection id="cockpit-dbus-byte-array">
      <title>cockpit.byte_array()</title>
<programlisting>
byte_array = cockpit.byte_array(value)
</programlisting>

      <para>A DBus byte array is represented as base64 data encoded in a string. This
        is a helper function for creating such a byte array.</para>
    </refsection>
  </refsection>

  <refsection id="cockpit-http">
    <title>HTTP Access</title>

    <para>Cockpit allows access to local HTTP and REST services via this API.</para>

    <para>This is not a general purpose HTTP request API. In particular in only accesses unix sockets
      and localhost ports on the server. Use your browser's <code>XmlHttpRequest</code> API for other
      more general HTTP access.</para>

    <refsection id="cockpit-http-constructor">
      <title>cockpit.http()</title>
<programlisting>
http = cockpit.http(endpoint, [options])
http = cockpit.http(options)
</programlisting>

      <para>Create a new HTTP client. The <code>endpoint</code> can be a file path starting with
        <code>/</code> to connect to a unix socket, or it can be a port number to connect to.</para>

      <variablelist>
        <varlistentry>
          <term><code>"address"</code></term>
          <listitem><para>Connect to an address other than localhost. Must be a valid host name or IP address.
            To use this option you also must provide a port number.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term><code>"connection"</code></term>
          <listitem><para>A connection identifier. Subsequent channel requests with the same
            identifier will try to use the same connection if it is still open.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"superuser"</code></term>
          <listitem><para>Set to <code>"require"</code> to open this channel as root. If the
            currently logged in user is not permitted to become root (eg: via <code>pkexec</code>)
            then the <code>channel</code> will immediately be
            <link linkend="cockpit-channels-close-ev">closed</link> with a <code>"access-denied"</code>
            problem code.</para>
          <para>Set to <code>"try"</code> to try to make the request as root, but if that fails,
            fall back to perform an unprivileged request.</para></listitem>
        </varlistentry>
      </variablelist>

    </refsection>

    <refsection id="cockpit-http-get">
      <title>http.get()</title>
<programlisting>
request = http.get(path, [params, [headers]])
</programlisting>
      <para>Perform an HTTP GET request for the given <code>path</code>. If the <code>params</code>
        is specified it should be a plain javascript object, which will be turned into a query string.</para>
      <para>Optionally a plain javascript object containing headers can be included in the
        <code>headers</code> argument.</para>
      <para>The return value is a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete if the request happens successfully, or fail if there's a problem.</para>
    </refsection>

    <refsection id="cockpit-http-post">
      <title>http.post()</title>
<programlisting>
request = http.post(path, body, [headers])
</programlisting>
      <para>Perform an HTTP POST request for the given <code>path</code>. The <code>body</code>
        can be a string, or a javascript plain object, which will be encoded as JSON data. If
        <code>body</code> is <code>undefined</code> or <code>null</code> then an empty HTTP body
        will be sent.</para>
      <para>Optionally a plain javascript object containing headers can be included in the
        <code>headers</code> argument.</para>
      <para>The return value is a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete if the request happens successfully, or fail if there's a problem.</para>
    </refsection>

    <refsection id="cockpit-http-request">
      <title>http.request()</title>
<programlisting>
request = http.request(options)
</programlisting>
      <para>Perform an HTTP request. The <code>options</code> can contain the following:</para>

      <variablelist>
        <varlistentry>
          <term><code>"body"</code></term>
          <listitem><para>The HTTP request body. If you do not specify a body, then you must
            call <link linkend="cockpit-http-input">request.input()</link> to complete the body
            and allow the request to start.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"headers"</code></term>
          <listitem><para>A javascript plain object containing HTTP headers.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"method"</code></term>
          <listitem><para>The HTTP method. Defaults to <code>"GET"</code>.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"params"</code></term>
          <listitem><para>A javascript plain object containing query string parameters.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"path"</code></term>
          <listitem><para>The HTTP path. Defaults to <code>/</code>.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>The return value is a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete if the request happens successfully, or fail if there's a problem.</para>
    </refsection>

    <refsection id="cockpit-http-done">
      <title>request.done()</title>
<programlisting>
request.done(function(data) { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        method. It sets up a handler to be called when the request finishes successfully.</para>
      <para>The <code>data</code> argument contains the body result of the request.
        If it a string, unless the process was opened in binary mode, in which case the
        <code>data</code> is an array of bytes. If a
        <code><link linkend="cockpit-http-stream">request.stream()</link></code>
        handler is set up, then any standard output data consumed by the handler will not
        be included in the <code>data</code> argument.</para>
    </refsection>

    <refsection id="cockpit-http-fail">
      <title>request.fail()</title>
<programlisting>
request.fail(function(exception[, data]) { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink> method.
        It sets up a handler to be called when the request fails, or returns an error code.</para>

      <para>The <code>exception</code> object passed to the handler can have the
        following fields:</para>

      <variablelist>
        <varlistentry>
          <term><code>problem</code></term>
          <listitem><para>A <link linkend="cockpit-problems">problem code</link> string when
            a problem occurred starting or communicating with the server. This is <code>null</code>
            if the process exited or was terminated.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>status</code></term>
          <listitem><para>The numeric status of the response. This is <code>null</code> if
            no response was received.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>reason</code></term>
          <listitem><para>A string reason returned in the response. This is <code>null</code> if
            no response was received.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>message</code></term>
          <listitem><para>A string message returned in the response. This is <code>null</code> if
            no response was received.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>If the request returned a response body, it will be available in
        the <code>data</code> argument. Otherwise this argument will be <code>undefined</code>.</para>
    </refsection>

    <refsection id="cockpit-http-always">
      <title>request.always()</title>
<programlisting>
request.always(function() { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink> method.
        It sets up a handler to be called when when the process completes, whether it exits successfully,
        fails, terminates, or exits with a failure.</para>
    </refsection>

    <refsection id="cockpit-http-response">
      <title>request.response()</title>
<programlisting>
request.response(function(status, headers) { ... })
</programlisting>
      <para>This sets up a handler to be called when the HTTP request gets the initial response
        from the server. The <code>status</code> argument is the HTTP status integer, and the
        <code>headers</code> is a plain javascript object containing the headers of the
        response.</para>
    </refsection>

    <refsection id="cockpit-http-stream">
      <title>request.stream()</title>
<programlisting>
request.stream(function(data) { ... })
</programlisting>
      <para>This sets up a handler to be called when the request returns output data. The
        handler will be called multiple times.</para>
      <para>Only one handler may be registered at a time. Registering an additional handler
        replaces the previous one. The handler receives either string <code>data</code> or
        an array of binary bytes as its argument. A stream handler may return a number, which
        indicates the number of characters or bytes consumed from <code>data</code>. Any data
        not consumed will be included again the next time the handler is called.</para>
      <para>If a <code>request.stream()</code> handler is set up, then the
        <code><link linkend="cockpit-http-done">request.done()</link></code> handlers will
        only get any remaining data not consumed by the stream handler.</para>
    </refsection>

    <refsection id="cockpit-http-input">
      <title>request.input()</title>
<programlisting>
request.input(data, [stream])
</programlisting>
      <para>This method writes <code>data</code> to the HTTP request body. It is only valid
        if no <code>"body"</code> has been specified in
        <link linkend="cockpit-http-request">http.request()</link> options. If <code>stream</code>
        is <code>true</code> then this function can be called again to provide further data.</para>
    </refsection>

    <refsection id="cockpit-http-close">
      <title>request.close()</title>
<programlisting>
request.close([problem])
</programlisting>
      <para>Cancel the request. If <code>problem</code> is specified it should be a
        standard <link linkend="cockpit-problems">problem code</link> string.</para>
    </refsection>

  </refsection>

<refsection id="cockpit-permission">
    <title>Permission Lookup</title>

    <para>Cockpit provides a mechanism for checking if the current user satisfies a
      given criteria. Currently capable of checking for root users, and group
      membership. This is meant for updating UI elements based on what actions the
      user can perform. It is <emphasis>not an access control mechanism</emphasis>.</para>

    <refsection id="cockpit-permission-constructor">
      <title>cockpit.permission()</title>
<programlisting>
permission = cockpit.permission([options])
</programlisting>

      <para>Create a new permission object to check if the current user has permission.
        The "root" user is always given permission. The <code>options</code> argument
        can contain a <code>"group"</code> field, and members of that group are also
        given permission.</para>
    </refsection>

    <refsection id="cockpit-permission-allowed">
      <title>permission.allowed</title>

      <para>A boolean value which indicates if the permission is allowed or not. This will
        be <code>null</code> if the permission is unknown, or there was an error checking
        the permission or the permission data has not yet loaded. This property will update
        asynchronously and if you wish to be notified of changes connect to the
        <link linkend="cockpit-permission-changed">permission.onchanged</link> event.</para>
    </refsection>

    <refsection id="cockpit-permission-changed">
      <title>permission.onchanged</title>
<programlisting>
$(permission).on("changed", function() { ... })
</programlisting>
      <para>This event is fired when the permission changes. In particular the
        <link linkend="cockpit-permission-allowed">permission.allowed</link> property.</para>
    </refsection>

    <refsection id="cockpit-permission-close">
      <title>permission.close()</title>
<programlisting>
permission.close()
</programlisting>
      <para>Closes the permission object and tears down any registered callbacks and dbus subscriptions.</para>
    </refsection>

  </refsection>

  <refsection id="cockpit-locale">
    <title>Localization</title>

    <para>Cockpit provides a
      <ulink url="https://www.gnu.org/software/gettext/"><code>gettext()</code></ulink> like
      API for easy translation of strings.</para>

    <refsection id="cockpit-locale-language">
      <title>cockpit.language</title>
      <para>The current locale language code. This is set based on the
        <link linkend="cockpit-locale-locale"><code>cockpit.locale()</code></link> data loaded.</para>
    </refsection>

    <refsection id="cockpit-locale-locale">
      <title>cockpit.locale()</title>
<programlisting>
cockpit.locale(po)
</programlisting>

      <para>Load locale information for a given <code>po</code> data. The data should
        be JSON data in the <ulink url="https://www.npmjs.org/package/po2json">po2json</ulink>
        format. The data will be loaded globally. If <code>po</code> data has already been
        loaded, then this will extend that loaded data with additional strings. Any identical
        translations strings will be replaced with the new strings.</para>

      <para>Various methods such as
        <link linkend="cockpit-locale-gettext"><code>cockpit.gettext()</code></link> make use
        of the loaded data.</para>
    </refsection>

    <refsection id="cockpit-locale-gettext">
      <title>cockpit.gettext()</title>
<programlisting>
translated = cockpit.gettext([context], string)
var _ = cockpit.gettext
var C_ = cockpit.gettext
translated = _("string")
translated = C_("context", "string")
</programlisting>

      <para>Lookup <code>string</code> for translation in the loaded locale data. The translated string will
        be returned, or <code>string</code> will be returned if no such translated string is
        present. The <code>context</code> argument is an optional string used to qualify the
        string.</para>

      <para>This function can be assigned to a variable called <code>_</code> (underscore) which
        will make your code work with the typical <code>_("string")</code> syntax.</para>
    </refsection>

    <refsection id="cockpit-locale-noop">
      <title>cockpit.noop()</title>
<programlisting>
var N_ = cockpit.noop
var NC_ = cockpit.noop
</programlisting>

      <para>A noop function suitable for assigning to <code>N_</code> or <code>NC_</code> so that
        gettext scanners will be able to find translatable strings. More specifically this function
        returns its last argument.</para>
    </refsection>

    <refsection id="cockpit-locale-ngettext">
      <title>cockpit.ngettext()</title>
<programlisting>
translated = cockpit.ngettext([context], string1, stringN, number)
</programlisting>

      <para>Lookup a string appropriate for a pluralization form of the <code>number</code>.
        Various languages have complex pluralization forms that go far between the singular
        and plural forms speakers of English are familiar with. If no such translated
        string is found then either one of <code>string1</code> or <code>stringN</code> is
        returned according to simple pluralization rules.</para>

      <para>The <code>context</code> argument is an optional string used to qualify the string.</para>
    </refsection>

    <refsection id="cockpit-locale-translate">
      <title>cockpit.translate()</title>
<programlisting>
cockpit.translate([sel])
</programlisting>

      <para>The document will be scanned for translatable tags and they will be translated according
        to the strings in loaded locale data. If <code>sel</code> is specified, this should be a jQuery
        selector for the specific part of the document to translate.</para>
    </refsection>

  </refsection>

  <refsection>
    <title>File Access</title>

    <para>Reading, writing, and watching files.</para>

<programlisting>
file = cockpit.file(path,
                    { syntax: syntax_object,
                      binary: boolean
                    })

promise = file.read()
promise
    .done(function (content, tag) { ... })
    .fail(function (error) { ... })

promise = file.replace(content, [ expected_tag ])
promise
    .done(function (new_tag) { ... })
    .fail(function (error) { ... })

promise = file.modify(callback, [ initial_content, initial_tag ]
promise
    .done(function (new_content, new_tag) { ... })
    .fail(function (error) { ... })

file.watch(function (content, tag, [error]) { })

file.close()
</programlisting>

    <refsection>
      <title>Simple reading and writing</title>

      <para>You can read a file with code like this:</para>
<programlisting>
cockpit.file("/path/to/file").read().
    done(function (content, tag) {
        ...
    }).
    fail(function (error) {
        ...
    });
</programlisting>
      <para>The <code>read()</code> method returns a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>.</para>
      <para>When successful, the promise will be resolved with the content of the
        file. Unless you specify options to change this (see below), the file
        is assumed to be text in the UTF-8 encoding, and <code>content</code>
        will be a string.</para>
      <para>The tag that is passed to the <code>done()</code> callback is a short
        string that is associated with the file and changes whenever the
        content of the file changes.  It is meant to be used with <code>replace()</code>.</para>
      <para>It is not an error when the file does not exist. In this case, the
        <code>done()</code> callback will be called with a <code>null</code>
        value for <code>content</code> and <code>tag</code> is <code>"-"</code>.</para>
      <para>To write to a file, use code like this:
<programlisting>
cockpit.file("/path/to/file").replace("my new content\n").
    done(function (tag) {
        ...
    }).
    fail(function (error) {
        ...
    });
</programlisting>
      </para>
      <para>The <code>replace()</code> method returns a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>.</para>
      <para>When the promise is resolved, the file has been atomically replaced
        (via the <code>rename()</code> syscall) with the new content. As with
        <code>read()</code>, by default the new content is a string and will
        be written to the file as UTF-8. The returned tag corresponds to the
        new content of the file.</para>
      <para>When the promise is rejected because of an error, the file or its meta
        data has not been changed in any way.</para>
      <para>As a special case, passing the value <code>null</code> to
        <code>replace()</code> will remove the file.</para>
      <para>The <code>replace()</code> method can also check for conflicting
        changes to a file.  You can pass a tag (as returned by
        <code>read()</code> or <code>replace()</code>) to
        <code>replace()</code>, and the file will only be replaced if it still
        has the given tag.  If the tag of the file has changed,
        <code>replace()</code> will fail with an error object that has
        <code>error.problem == "change-conflict"</code>. See
        <code>modify()</code> below for a convenient way to achieve
        transactional updates to a file.</para>
    </refsection>

    <refsection>
      <title>File format</title>
      <para>By default, a file is assumed to be text encoded in UTF-8, and the
        <code>read()</code> and <code>replace()</code> functions use strings to
        represent the content.</para>
      <para>By specifying the <code>syntax.parser()</code> and
        <code>syntax.stringify()</code> options, you can cause
        <code>read()</code> to parse the content before passing it back to
        you, and <code>replace()</code> to unparse it before writing.</para>
      <para>The main idea is to be able to write <code>{ syntax: JSON }</code>, of
        course, but you can easily pass in individual functions or make your
        own parser/unparser object:
<programlisting>
cockpit.file("/path/to/file.json", { syntax: JSON })

var syntax_object = { parse:     my_parser,
                      stringify: my_unparser
                    };

cockpit.file("/path/to/file", { syntax: syntax_object })
</programlisting>
        Any exceptions thrown by the <code>parse()</code> and
        <code>stringify()</code> functions are caught and reported as read or
        write errors.</para>
      <para>The <code>null</code> value that is used to represent the content of a
        non-existing file (see "Simple reading and writing", above) is not
        passed through the <code>parse()</code> and <code>stringify()</code>
        functions.</para>
    </refsection>

    <refsection>
      <title>Binary files</title>
      <para>By default the content of the file is assumed to be text encoded as
        UTF-8 and it can not contain zero bytes.  The content is represented
        as a JavaScript string with <code>read()</code>,
        <code>replace()</code>, etc. By setting the <code>binary</code> option
        to true when creating the proxy, no assumptions are placed on the
        content, and it is represented as a <code>Uint8Array</code> in
        JavaScript.</para>
    </refsection>

    <refsection>
      <title>Atomic modifications</title>
      <para>Use <code>modify()</code> to modify the content of the file safely.  A
        call to <code>modify()</code> will read the content of the file, call
        <code>callback</code> on the content, and then replace the content of
        the file with the return value of the callback.</para>
      <para>The <code>modify()</code> method uses the <code>read()</code> and
        <code>replace()</code> methods internally in the obvious way. Thus,
        the <code>syntax.parse()</code> and <code>syntax.stringify()</code>
        options work as expected, <code>null</code> represents a non-existing
        file, and the watch callbacks are fired.</para>
      <para>It will do this one or more times, until no other conflicting changes
        have been made to the file between reading and replacing it.</para>
      <para>The callback is called like this
<programlisting>
new_content = callback (old_content)
</programlisting>
        The callback is allowed to mutate <code>old_content</code>, but note
        that this will also mutate the objects that are passed to the watch
        callbacks. Returning <code>undefined</code> from the proxy is the
        same as returning <code>old_content</code>.</para>
      <para>The <code>modify()</code> method returns a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>.</para>
      <para>The promise will be resolved with the new content and its tag, like so
<programlisting>
function shout(old_content) {
   return old_content.toUpperCase();
}

cockpit.file("/path/to/file").modify(shout).
    done(function (content, tag) {
        ...
    }).
    fail(function (error) {
        ...
    });
</programlisting>
        If you have cached the last content and tag results of the
        <code>read()</code> or <code>modify()</code> method, or the last
        values passed to a watch callback, you can pass them to
        <code>modify()</code> as the second and third argument.  In this case,
        <code>modify()</code> will skip the initial read and start with the
        given values.</para>
    </refsection>

    <refsection>
      <title>Change notifications</title>
      <para>Calling <code>watch()</code> will start monitoring the file for
        external changes.
<programlisting>
handle = file.watch(callback);
</programlisting>
        Whenever a change occurs, the <code>callback()</code> is called with
        the new content and tag of the file.  This might happen because of
        external changes, but also as part of calls to <code>read()</code>,
        <code>replace()</code>, and <code>modify()</code>.</para>
      <para>When a read error occurs, the <code>callback()</code> is called with
        an error as a third argument. Write errors are not reported via the watch callback.</para>
      <para>Calling <code>watch()</code> will also automatically call
        <code>read()</code> to get the initial content of the file.</para>
      <para>Thus, you normally don't need to call <code>read()</code> at all when
        using <code>watch()</code>.</para>
      <para>To free the resources used for monitoring, call <code>handle.remove()</code>.</para>
    </refsection>

    <refsection>
      <title>Closing</title>
      <para>Call the <code>close()</code> method on a file proxy to cancel all
        ongoing operations, such as reading, writing, and monitoring. The
        proxy should not be used after closing it.</para>
    </refsection>

  </refsection>

  <refsection>
    <title>Metrics</title>

    <para>Metrics about the system can be retrieved from several sources using
      <link linkend="cockpit-metrics"><code>cockpit.metrics()</code></link> metrics channels.
      The metrics are made available as series data, and can be used with the
      <link linkend="cockpit-series"><code>cockpit.series()</code></link> and
      <link linkend="cockpit-grid"><code>cockpit.grid()</code></link> facilities.</para>

    <refsection id="cockpit-metrics">
      <title>cockpit.metrics()</title>
<programlisting>
metrics = cockpit.metrics(interval, options, cache)
</programlisting>

      <para>Opens a new metrics channel. The data retrieved will be available in the
        <link linkend="cockpit-metrics-series"><code>metrics.series</code></link> series sink, and can
        be used together with <link linkend="cockpit-grid"><code>cockpit.grid()</code></link> objects.</para>

      <para>The <code>interval</code> is in milliseconds, and is the granularity of the series data
        retrieved. Any grids consuming the data must have the same interval.</para>

      <para>The <code>cache</code> argument is a cache identifier. If
      specified, then this metrics channel will share data with other
      metrics channels of the same identifier. Make sure to use a
      globally unique string.</para>

      <para>The <code>options</code> argument is either a javascript
      plain object, or an array of those.  Each object can have the
      following fields.</para>

      <variablelist>
        <varlistentry>
          <term><code>"metrics"</code></term>
          <listitem><para>An array of full metric descriptions, as
          javascript objects. The specifics of these, and how to
          determine which ones to use, can unfortunately only be found
          in the low-level protocol documentation. This option is
          required.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"source"</code></term>
          <listitem><para>The source to use for real-time data.  This
          is used by the <code>follow</code> method, see below.  Set
          to <code>"internal"</code> to retrieve internal metrics read
          by the bridge. If set to <code>"direct"</code> or
          <code>"pmcd"</code> then data will be retrieved from <ulink
          url="http://pcp.io">PCP</ulink>if it is available. The
          default is <code>"internal"</code>.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"archive_source"</code></term>
          <listitem><para>The source to use for retrieving historical
          data.  This is used by the <code>fetch</code> method, see
          below.  Set to <code>"pcp-archive"</code> to retrieve data
          from PCP archives.  The default is not to try to retrieve
          historical data.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>When the <code>options</code> argument is an array of
      javascript objects, then the metrics channel tries to use them in
      order until one succeeds.  This way, you can prefer PCP as the
      source but fall back to internal metrics when PCP is not
      available, for example.  The channel gives no indication which
      of the options has been used, and <code>fetch</code> and
      <code>follow</code> might use different entries from the
      list.</para>
    </refsection>

    <refsection id="cockpit-metrics-fetch">
      <title>metrics.fetch()</title>
<programlisting>
metrics.fetch(beg, end)
</programlisting>

      <para>Retrieve archived metrics data between <code>beg</code> and <code>end</code>. The
        arguments can either be numbers, in which case they are interval based offsets, or they
        can be javascript Date objects.</para>
    </refsection>

    <refsection id="cockpit-metrics-follow">
      <title>metrics.follow()</title>
<programlisting>
metrics.follow()
</programlisting>

      <para>Start retrieving live metrics data as it become available.</para>
    </refsection>

    <refsection id="cockpit-metrics-close">
      <title>metrics.close()</title>
<programlisting>
metrics.close()
</programlisting>

      <para>Stop the retrieval of metrics and release resources.</para>
    </refsection>

    <refsection id="cockpit-metrics-series">
      <title>metrics.series</title>
      <para>The series sink where data retrieved data will be processed.</para>
    </refsection>

  </refsection>

  <refsection>
    <title>Series Data</title>

    <para>Series data consists of values along a continuous (usually time) axis. We
      can place these in grids which expose a distinct subset of these values. These are
      the underlying mechanism for displaying metrics data in graphs.</para>

    <refsection id="cockpit-grid">
      <title>cockpit.grid()</title>
<programlisting>
grid = cockpit.grid(interval, [beg, end])
</programlisting>

      <para>Creates a grid object to contain series data.</para>

      <para>The <code>interval</code> is the granularity of the grid. Usually this is
        a number of milliseconds, when used with time series data. The <code>beg</code>
        and <code>end</code> are the bounds of the grid. If omitted they will be set to
        zero for an initially empty grid.</para>

      <para>If <code>beg</code> and/or <code>end</code> are negative (including negative
        zero) then they are interpreted in number of intervals relative to the current
        time. Thus cockpit.grid(1000, -300, -0) will create a grid for the most recent
        5 minutes.</para>
    </refsection>

    <refsection id="cockpit-grid-add">
      <title>grid.add()</title>
<programlisting>
row = grid.add(series, path)
row = grid.add(callback, [early])
row = grid.add()
</programlisting>

      <para>Adds a row to the grid. The returned <code>row</code> is a Javascript array that will contain
        series data. The arguments control how the row is populated from the series data.
        The <code>row</code> is a sparse array. Its <code>row.length</code> will not match the
        expected size of the grid, unless and until the row has been completely filled in. The first
        index of the <code>row</code> will contain the data from the series data at the
        <link linkend="cockpit-grid-beg"><code>grid.beg</code></link> offset.</para>

      <para>When no arguments are passed, an empty row is added, and it is not populated with data.</para>

      <para>When called with a <code>series</code> and <code>path</code> argument then the row
        will be populated directly with series data. The <code>series</code> can either be a
        <link linkend="cockpit-series">series object</link> or an object that has an <code>obj.series</code>
        property. The <link linkend="cockpit-series-interval">series interval</link> must match the
        interval of this grid.
        If <code>path</code> is missing or empty, then the series data is placed into the row
        directly. Otherwise <code>path</code> indicates which part of the series data to place in the
        row. When <code>path</code> is an array, it is used as a set of property names or array indexes
        to follow into nested series data. When <code>path</code> is a dotted string, it is split and used
        the same way to locate the correct value in nested series data. The exact format of the series
        data depends on its producer, and relevant paths will be documented there.</para>

      <para>If a <code>callback</code> function is specified, then it will be invoked to provide series data
        for the row. The function is invoked as <code>callback(row, index, count)</code>, where the
        <code>row</code> is the row to fill in, the <code>index</code> is the index to start filling in and
        <code>count</code> is the number of items to fill in. The <code>this</code> variable will be set
        to the grid while invoking the <code>callback</code>. The callback is called after other data
        rows for a given series have been filled in. Callbacks are called in the order added, unless the
        <code>early</code> argument is set to <code>true</code>, in which case the callback is called earlier
        than callbacks without the <code>early</code> argument set.</para>

      <para>To remove the row use the
        <link linkend="cockpit-grid-remove"><code>grid.remove()</code> method.</link>
      </para>

      <para>The row will start being populated with data when the <code>series</code> produces data.
        To make this happen right away, use the
        <link linkend="cockpit-grid-sync"><code>grid.sync()</code></link> method.</para>

    </refsection>

    <refsection id="cockpit-grid-remove">
      <title>grid.remove()</title>
<programlisting>
grid.remove(row)
</programlisting>

      <para>Remove a previously added <code>row</code> from the grid. The row will no longer be updated
        with series data.</para>
    </refsection>

    <refsection id="cockpit-grid-sync">
      <title>grid.sync()</title>
<programlisting>
grid.sync()
</programlisting>

      <para>Load or reload data from the series into the rows. This does not clear the rows before
        populating them. Some data may be populated immediately, others may have to wait until data
        can be loaded. Internally this function calls
        <link linkend="cockpit-series-load"><code>series.load()</code></link> for each series.</para>

      <para>All rows with callbacks will be invoked to regenerate all the data. The
        <link linkend="cockpit-grid-onnotify"><code>grid.onnotify</code></link> event will be triggered.
        It is not necessary to call this function after a call of the
        <link linkend="cockpit-grid-move"><code>grid.move()</code></link> method.</para>

    </refsection>

    <refsection id="cockpit-grid-move">
      <title>grid.move()</title>
<programlisting>
grid.move(beg[, end])
</programlisting>

      <para>Move the grid to new <code>beg</code> and <code>end</code> range. Data will be
        discarded from the rows and <link linkend="cockpit-grid-sync"><code>grid.sync()</code></link>
        will be called to load or reload series data for the new range of offsets.</para>

      <para>If <code>end</code> is not specified it will be set to <code>beg</code>. If <code>beg</code>
        and/or <code>end</code> are negative (including negative zero) then they will be set to the
        number of intervals prior to the current time taken as an interval.</para>

      <para>If <code>beg</code> and/or <code>end</code> are negative (including negative
        zero) then they are interpreted in number of intervals relative to the current
        time. Thus cockpit.grid(1000, -300, -0) will create a grid for the most recent
        5 minutes.</para>
    </refsection>

    <refsection id="cockpit-grid-walk">
      <title>grid.walk()</title>
<programlisting>
grid.walk()
</programlisting>

      <para>Move the grid forward every
        <link linkend="cockpit-grid-interval"><code>grid.interval</code></link> milliseconds. To stop
        moving forward, call <link linkend="cockpit-grid-move"><code>grid.move()</code></link>.</para>
    </refsection>

    <refsection id="cockpit-grid-notify">
      <title>grid.notify()</title>
<programlisting>
grid.notify(index, count)
</programlisting>

      <para>This function is called to have rows with callbacks recalculate their data. It is not
        normally necessary to call this function, as it will be invoked automatically when new
        series data is available or has been loaded. This function triggers the
        <link linkend="cockpit-grid-onnotify"><code>grid.onnotify</code></link> event.</para>

    </refsection>

    <refsection id="cockpit-grid-onnotify">
      <title>grid.onnotify</title>
<programlisting>
$(grid).on("notify", function(index, count) { ... });
</programlisting>

      <para>An event that is triggered when some part of the series data in grid changes. The
        <code>index</code> is the row index where things changed, and the <code>count</code>
        is the length of the data that changed.</para>

    </refsection>

    <refsection id="cockpit-grid-close">
      <title>grid.close()</title>
<programlisting>
grid.close()
</programlisting>

      <para>Close the grid, and stop updating the rows.</para>
    </refsection>

    <refsection id="cockpit-grid-interval">
      <title>grid.interval</title>

      <para>The granularity of the grid. For time series data this is an interval in
        milliseconds. In order to use a given
        <link linkend="cockpit-grid">grid</link> and
        <link linkend="cockpit-series">series</link> together, their interval properties
        must match.</para>
    </refsection>

    <refsection id="cockpit-grid-beg">
      <title>grid.beg</title>

      <para>The beginning offset of the series data in the grid. Do not set this property
        directly. Use the <link linkend="cockpit-grid-move">grid.move()</link> method instead.</para>
    </refsection>

    <refsection id="cockpit-grid-end">
      <title>grid.end</title>

      <para>The ending offset of the series data in the grid. Do not set this property
        directly. Use the <link linkend="cockpit-grid-move">grid.move()</link> method instead.</para>
    </refsection>

    <refsection id="cockpit-series">
      <title>cockpit.series()</title>
<programlisting>
series = cockpit.series(interval, [cache, fetch])
</programlisting>

      <para>Create a new sink of series data. This is usually done by producers of series data,
        and it is rare to invoke this function directly.</para>

      <para>The <code>interval</code> is the granularity of the series data. For time series data
        this is an interval in milliseconds. If a <code>cache</code> string is specified, series data
        will be cached across frames for series with the same <code>cache</code> cache identifier
        to load and/or reload.</para>

      <para>If a <code>fetch</code> callback
        is specified, then it will be invoked when grids request certain ranges of data. The
        <code>fetch</code> callback is invoked with <code>function fetch(beg, end) { ... }</code>
        range offsets. The <link linkend="cockpit-series-input">series.input()</link> should be
        called with data retrieved, either immediately or at a later time. The callback may be
        called multiple times for the same ranges of data. It is up to the callback to determine
        when or whether it should retrieve the data more than once.</para>

      <para>A producer of series data, usually calls this function and creates itself a
        <code>obj.series</code> property containing this series object.</para>
    </refsection>

    <refsection id="cockpit-series-input">
      <title>series.input()</title>
<programlisting>
series.input(beg, items[, mapping])
</programlisting>

      <para>Send series data into the series sink. Any grids that have added rows based on this
        series, will have data filled in. The <code>beg</code> is the beginning offset of
        <code>items</code>. The <code>items</code> are an array one or more series data items.</para>

      <para>Producers may wish to provide additional properties that can be used in lookup paths that
        rows can pull from. This is done in the <code>mapping</code> argument. If specified it is
        a tree of objects. Each sub object should have a property with the name <code>""</code>
        empty string, which will be used as the property name or index in place of the one used
        in the lookup path.</para>

    </refsection>

    <refsection id="cockpit-series-load">
      <title>series.load()</title>
<programlisting>
series.load(beg, end)
</programlisting>

      <para>Load data from the series into any grids that have rows based on this series data.
        Any cached data will be filled in immediately. Any data not cached, will be requested
        from the producer, if possible, and may arrive at a later time.</para>

      <para>The <code>beg</code> and <code>end</code> denote the range of data to load.</para>
    </refsection>

    <refsection id="cockpit-series-interval">
      <title>series.interval</title>

      <para>The granularity of the series. For time series data this is an interval in
        milliseconds. In order to use a given
        <link linkend="cockpit-grid">grid</link> and
        <link linkend="cockpit-series">series</link> together, their interval properties
        must match.</para>
    </refsection>

    <refsection id="cockpit-series-limit">
      <title>series.limit</title>

      <para>The maximum number of items to cache for loading and/or reloading. You can
        change this value to a different number. Having a number close to zero will break
        certain usage of grids, such as
        <link linkend="cockpit-grid-walk"><code>grid.walk()</code></link>.</para>
    </refsection>

  </refsection>

  <refsection>
    <title>Utilities</title>

    <para>Various utility functions.</para>

    <refsection id="cockpit-format">
      <title>cockpit.format()</title>
<programlisting>
string = cockpit.format(template, args)
string = cockpit.format(template, [arg, ...])
</programlisting>

      <para>Format a string interpolating <code>args</code> into <code>template</code> using
        shell like syntax. The <code>args</code> may be either an array or javascript object.
        The <code>template</code> can contain fields that look like <code>$name</code> or
        <code>${name}</code> or <code>$0</code>. Numeric fields are used with array
        <code>args</code> and start at zero.</para>

      <para>In the second form, multiple <code>arg</code> arguments may be passed directly,
        and interpolated as as numeric fields in the <code>template</code>.</para>
    </refsection>

    <refsection id="cockpit-format-bytes">
      <title>cockpit.format_bytes()</title>
<programlisting>
string = cockpit.format_bytes(number, [factor])
array = cockpit.format_bytes(number, [factor, separate])
</programlisting>
      <para>Formats <code>number</code> into a displayable <code>string</code> with a suffix, such as
        <emphasis>KB</emphasis> or <emphasis>MB</emphasis>. Returns an <code>array</code> of the
        formatted number and the suffix if <code>separate</code> is set to <code>true</code>.</para>

      <para>If specifying 1000 or 1024 is specified as a <code>factor</code> then an appropriate suffix
        will be chosen. By default the <code>factor</code> is 1024.  You can pass a string suffix as a
        <code>factor</code> in which case the resulting number will be formatted with the same suffix.</para>

      <para>If the <code>number</code> is less than the <code>factor</code> or an unknown factor
        was passed in, then the formatted number is returned without a suffix. If <code>separate</code>
        is true, returns an array of <code>[formatted_number, suffix]</code> unless no suffix is returned.</para>
    </refsection>

    <refsection>
      <title>cockpit.format_bytes_per_sec()</title>
  <programlisting>
   string = cockpit.format_bytes_per_sec(number)
  </programlisting>
      <para>Format <code>number</code> of bytes into a displayable speed <code>string</code>.</para>
    </refsection>

    <refsection>
      <title>cockpit.format_bits_per_sec()</title>
  <programlisting>
    string = cockpit.format_bits_per_sec(number)
  </programlisting>
      <para>Format <code>number</code> of bits into a displayable speed <code>string</code>.</para>
    </refsection>
  </refsection>

  <refsection id="cockpit-packages">
    <title>Manifest Info</title>

    <para>You can load manifest info by loading the <code>./manifest.json</code> file in
      your package. In addition there is a shortcut: if you're using AMD loading you can
      use a special module id to access all the manifests in one shot:</para>

<programlisting>
define([
    'manifests',
    'other.dep'
], function(manifests, other) {
    var manifest = manifests['package'];
});
</programlisting>

  </refsection>

  <refsection id="cockpit-cache">
    <title>Object Cache</title>

    <para>If the same information is displayed by multiple components in Cockpit,
      <code>cockpit.cache()</code> provides a way to share data between them. The shared
      data should be simple objects, arrays, and values, and not contain functions or
      other objects.</para>

    <refsection>
      <title>cockpit.cache()</title>
<programlisting>
cache = cockpit.cache(key, provider, consumer)
</programlisting>

      <para>Create a new cache object. The <code>key</code> should be a globally unique string
        that describes the data being cached. This string must describe the data, across all
        machines and all versions of cockpit. It is customary to include a version number in
        the <code>key</code> string.</para>

<programlisting>
function provider(result, key) {
    result("myvalue");

    return {
        close: function() {
            /* closed */
        }
    };
}
</programlisting>

      <para>The <code>provider</code> is a function that will be invoked to start retrieving
        data for the cache. It will be passed a <code>result</code> function as its first
        argument. The <code>result</code> should be invoked whenever new data is available.
        The <code>key</code> argument matches the key string the cache was created with.</para>

      <para>The <code>provider</code> can return an object with a <code>close</code> method.
        This method will be invoked when the cache no longer needs data from the provider.</para>

<programlisting>
function consumer(value, key) {
    /* ... */
}
</programlisting>

      <para>The <code>consumer</code> is a function that will be passed new values when they
        are available, whether they come from the <code>provider</code> or a source in a
        different component/frame.</para>

    </refsection>

    <refsection>
      <title>cache.close()</title>
<programlisting>
cache.close()
</programlisting>

      <para>Close a cache and stop calling its <code>consumer</code>. If the <code>provider</code>
        was invoked, then the <code>close()</code> method it returned will be invoked.</para>
    </refsection>

  </refsection>

  <refsection id="cockpit-channels">
    <title>Raw Channels</title>

    <para>At a low level Cockpit communicates with the system via messages passed
      through various channels. These are usually exposed via higher level APIs,
      such as the <code><link linkend="cockpit-spawn">cockpit.spawn()</link></code> function.
      It is rare to use raw channels directly.</para>

    <refsection id="cockpit-channels-channel">
      <title>cockpit.channel()</title>
<programlisting>
channel = cockpit.channel(options)
</programlisting>

      <para>This function creates a new channel for communication with the system.
        It returns a new channel object. The <code>options</code> argument is a
        plain object. At least the <code>"payload"</code> option is required, and
        based on the payload type, other options may be required.</para>

      <variablelist>
        <varlistentry>
          <term><code>"binary"</code></term>
          <listitem><para>Set to <code>true</code> to transfer binary payloads. Both messages
            sent via <link linkend="cockpit-channels-send"><code>channel.send()</code></link>
            and those received via
            <link linkend="cockpit-channels-message"><code>channel.onmessage</code></link>
            should be arrays of bytes, either <code>Uint8Array</code> or <code>Array</code>
            depending on browser support.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"host"</code></term>
          <listitem><para>The host to open the channel to. If no host is specified
            then the correct one will be automatically selected based on the page
            calling this function.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"payload"</code></term>
          <listitem><para>The payload type for the channel. Only specific payload
            types are supported.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"superuser"</code></term>
          <listitem><para>Set to <code>"require"</code> to open this channel as root. If the currently
            logged in user is not permitted to become root (eg: via <code>pkexec</code>) then the
            <code>channel</code> will immediately be
            <link linkend="cockpit-channels-close-ev">closed</link> with a <code>"access-denied"</code>
            problem code.</para>
          <para>Set to <code>"try"</code> to try to open the channel as root, but if that fails,
            then fall back to an unprivileged channel.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>The channel object returned has the following fields and methods and
        events. You should call the
        <code><link linkend="cockpit-channels-close">channel.close()</link></code>
        method when done with the channel.</para>

      <para>A valid channel will always be returned and the is ready to
        <code><link linkend="cockpit-channels-send">channel.send()</link></code>. The channel may
        <link linkend="cockpit-channels-close-ev">close shortly afterword</link> due
        to a failure.</para>
    </refsection>

    <refsection id="cockpit-channels-binary">
      <title>channel.binary</title>
      <para>Will be <code>true</code> for an binary channel. Will be set to <code>false</code> if the
        channel is textual.</para>
    </refsection>

    <refsection id="cockpit-channels-options">
      <title>channel.options</title>
      <para>The options used to open this channel. This should not be changed.</para>
    </refsection>

    <refsection id="cockpit-channels-valid">
      <title>channel.valid</title>
      <para>Will be <code>true</code> for an open channel. Will be set to <code>false</code> if the channel
        closes.</para>
    </refsection>

    <refsection id="cockpit-channels-send">
      <title>channel.send()</title>
<programlisting>
channel.send(data)
</programlisting>
      <para>Send a message over the channel. The contents of the message depends on the
        payload type of the channel. If a binary channel, then <code>data</code> is expected
        to be an <code>Array</code> of bytes or a <code>Uint8Array</code>. If not binary,
        then the <code>data</code> will be converted to a string if not already a string.</para>
    </refsection>

    <refsection id="cockpit-channels-control">
      <title>channel.control()</title>
<programlisting>
channel.control(options)
</programlisting>
      <para>Notify the channel to tune certain parameters on the fly. The <code>options</code>
        is a plain javascript object, and the contents depend on the <code>"payload"</code>
        of the channel.</para>
      <para>One common operation is to set <code>"command"</code> to <code>"done"</code> in the
        options field. To indicate that no further messages will be sent through the channel.</para>
    </refsection>

    <refsection id="cockpit-channels-close">
      <title>channel.close()</title>
<programlisting>
channel.close([options])
</programlisting>
      <para>Close the channel.</para>
      <para>If <code>options</code> is present it can be a plain javascript object
        containing additional channel close options to send to the peer. If closing for
        because of a problem, set the <code>"problem"</code> field to a
        <link linkend="cockpit-problems">problem code</link>. If <code>options</code>
        is not an object it will be treated as a <code>"problem"</code>.</para>
      <para>The <link linkend="cockpit-channels-close-ev">close event</link> will fire.
        A channel can also be closed by a peer or if the underlying transport closes.</para>
    </refsection>

    <refsection id="cockpit-channels-message">
      <title>channel.onmessage</title>
<programlisting>
$(channel).on("message", function(event, data) { ... })
channel.addEventListener("message", function(event, data) { ... })
</programlisting>
      <para>An event triggered when the channel receives a message. The message is
        passed as a string to the handler in the <code>data</code>. In the case of binary
        channels <code>data</code> is an <code>Uint8Array</code> or an <code>Array</code>
        of bytes if the former is not supported by the browser. The contents of
        the message depends on the payload type of the channel.</para>
    </refsection>

    <refsection id="cockpit-channels-oncontrol">
      <title>channel.oncontrol</title>
<programlisting>
$(channel).on("control", function(event, options) { ... })
channel.addEventListener("control", function(event, options) { ... })
</programlisting>
      <para>An event triggered when the channel receives an control message in the
        middle of the flow. One particular use is when the <code>command</code> is set to
        <code>"done"</code> then no further messages will be received in the channel.
        The exact form of these messages depend on the <code>"payload"</code> of the
        channel.</para>
    </refsection>

    <refsection id="cockpit-channels-close-ev">
      <title>channel.onclose</title>
<programlisting>
$(channel).on("close", function(options) { ... })
channel.addEventListener("close", function(event, options) { ... })
</programlisting>
      <para>An event triggered when the channel closes. This can happen either because
        <link linkend="cockpit-channels-close">channel.close()</link> function was called,
        or if the peer closed the channel, or the underlying transport closes.</para>
      <para>The <code>options</code> will contain various close information, including a
        <code>"problem"</code> field which will be set if the channel was closed because
        of a problem.</para>
    </refsection>

    <refsection id="cockpit-transport-origin">
      <title>cockpit.transport.origin</title>
<programlisting>
cockpit.transport.origin
</programlisting>
      <para>The HTTP origin that is being used by the underlying channel transport. This is
        read-only, you should not assign a value. If the browser supports
        <code>window.location.origin</code> then this will be identical to that value.</para>
    </refsection>

    <refsection id="cockpit-transport-host">
      <title>cockpit.transport.host</title>
<programlisting>
cockpit.transport.host
</programlisting>
      <para>The host that this transport is going to talk to by default. This is
        read-only, you should not assign a value. If the value is null that means that the
        transport has not been setup yet.</para>
    </refsection>

    <refsection id="cockpit-transport-options">
      <title>cockpit.transport.options</title>
<programlisting>
cockpit.transport.options
</programlisting>
      <para>Initialization options received over the underlying channel transport. These
        will be empty until connection is properly established.</para>
    </refsection>

    <refsection id="cockpit-transport-wait">
      <title>cockpit.transport.wait()</title>
<programlisting>
cockpit.transport.wait(callback)
</programlisting>
      <para>Call the <code>callback</code> function once the underlying channel transport is initialized.
        This will start the initialization if not already in progress or completed. If the
        channel transport is already initialized, then <code>callback</code> will be called
        immediately.</para>
    </refsection>

    <refsection id="cockpit-transport-close">
      <title>cockpit.transport.close()</title>
<programlisting>
cockpit.transport.close([problem])
</programlisting>
      <para>Close the underlying channel transport. All channels open channels will close.
        The <code>problem</code> argument should be a problem code string. If not specified
        it will default to <code>"disconnected"</code>.</para>
    </refsection>

    <refsection id="cockpit-transport-filter">
      <title>cockpit.transport.filter()</title>
<programlisting>
cockpit.transport.filter(function(message, channel, control) { ... })
</programlisting>
      <para>Add a filter to the underlying channel transport. All incoming messages will be
        passed to each of the filter callbacks that are registered.</para>
      <para>This function is rarely used.</para>
      <para>Filter callbacks are called in the order they are registered. If a filter
        callback returns <code>false</code> then the message will not be dispatched
        further, whether to other filters, or to channels, etc.</para>

      <para>The <code>message</code> is the string or array with the raw message including,
	the framing. If <code>channel</code> is set to a string this is a payload
	message in the specified channel. If <code>control</code> is set then this is
	a control message, and the <code>control</code> argument contains the parsed
	JSON object of the control message.</para>
    </refsection>

    <refsection id="cockpit-transport-inject">
      <title>cockpit.transport.inject()</title>
<programlisting>
cockpit.transport.inject(message)
</programlisting>
      <para>Inject a message into the underlying channel transport. The <code>message</code>
        should be a <code>string</code> or an array of bytes, and should be valid
        according to the Cockpit message protocol.</para>
      <para>This function is rarely used. In general you should only <code>inject()</code>
        messages you got from a <code><link linkend="cockpit-transport-filter">filter()</link></code>.</para>
    </refsection>

    <refsection id="cockpit-base64-encode">
      <title>cockpit.base64_encode()</title>
<programlisting>
string = cockpit.base64_encode(data)
</programlisting>
      <para>Encode binary data into a string using the Base64 encoding. The <code>data</code>
        argument can either be a <code>string</code>, an <code>Array</code>, an <code>ArrayBuffer</code>
        or a <code>Uint8Array</code>. The return value is a string.</para>
    </refsection>

    <refsection id="cockpit-base64-decode">
      <title>cockpit.base64_decode()</title>
<programlisting>
data = cockpit.base64_decode(string, [constructor])
</programlisting>
      <para>Decode binary data from a Base64 encoded string. The <code>string</code>
        argument should be a javascript string. The returned <code>data</code>> will be an
        array of bytes.</para>
      <para>You can pass <code>Uint8Array</code>, <code>Array</code> or <code>String</code>
        as an alternate <code>constructor</code> if you want the decoded data in an
        alternate form. The default is to return an <code>Array</code>. Note that if you use a
        <code>String</code> for the decoded data, then you must guarantee that the data
        does not contain bytes that would be invalid for a string.</para>
    </refsection>

    <refsection id="cockpit-utf8-encoder">
      <title>cockpit.utf8_encoder()</title>
<programlisting>
encoder = cockpit.utf8_encoder([constructor])
</programlisting>
      <para>Create an encoder for encoding a string into a UTF8 sequence of bytes.</para>
      <para>You can pass <code>Uint8Array</code>, <code>Array</code> or <code>String</code>
        as an alternate <code>constructor</code> if you want the decoded data in an
        alternate form. The default is to return an <code>Array</code>.</para>
    </refsection>

    <refsection id="cockpit-utf8-encoder-encode">
      <title>encoder.encode()</title>
<programlisting>
data = encoder.encode(string)
</programlisting>
      <para>Encode a <code>string</code> into a UTF8 sequence of bytes.</para>
      <para>The resulting <code>data</code> is an array of bytes, but it's type may be
        modified by passing an alternate <code>constructor</code> to
        <link linkend="cockpit-utf8-encoder">cockpit.utf8_encoder()</link>.</para>
    </refsection>

    <refsection id="cockpit-utf8-decoder">
      <title>cockpit.utf8_decoder()</title>
<programlisting>
decoder = cockpit.utf8_decoder([fatal])
</programlisting>
      <para>Creates a decoder to decode a UTF8 sequence of bytes data into a string.</para>
      <para>If the <code>fatal</code> is set to <code>true</code> then the <code>decoder</code>
        will throw an exception when it encounters invalid UTF8 data. By default invalid data
        will be substituted with special UTF8 characters.</para>
    </refsection>

    <refsection id="cockpit-utf8-decoder-decode">
      <title>decoder.decode()</title>
<programlisting>
string = decoder.decode(data, [options])
</programlisting>
      <para>Decode an array of UTF8 bytes into a <code>string</code>. The <code>data</code>
        argument may be an <code>Array</code>, a <code>Uint8Array</code> or a string containing
        binary data.</para>
      <para>If <code>options</code> is passed it should be a plain javascript object. If
        <code>options</code> has a <code>stream</code> property equal to <code>true</code>,
        then multiple invocations of this function can be made with parts of the UTF8 sequence
        of bytes. Any trailing bytes that don't yet build a complete unicode character, will be
        cached until the next invocation. To drain the last data, call this function without
        the <code>stream</code> property set.</para>
    </refsection>

  </refsection>

  <refsection>
    <title>Cockpit Version Info</title>

    <refsection id="cockpit-info">
      <title>cockpit.info</title>
<programlisting>
cockpit.info["version"]
cockpit.info["build"]
</programlisting>
      <para>This object contains information about cockpit itself. Note that when cockpit is
        running on multiple servers, this only reflects the server that was connected to.
        The following fields are defined:</para>

      <variablelist>
        <varlistentry>
          <term><code>"build"</code></term>
          <listitem><para>A string containing build details.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"version"</code></term>
          <listitem><para>A string containing the cockpit version number. It is almost always
            incorrect to use this to make a decision in code.</para></listitem>
        </varlistentry>
      </variablelist>

    </refsection>
  </refsection>

</refentry>
