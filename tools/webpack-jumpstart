#!/bin/sh

# Download pre-built webpack for current git SHA from GitHub

# These are produced by .github/workflows/build-dist.yml for every PR and push.
# This is a lot faster than having to npm install and run webpack.

# Returns 0 when successful, 1 in case of an error, or 2 in case the cache
# entry couldn't be found (but might be available after waiting a bit longer).

GITHUB_REPO='cockpit-dist'
SUBDIR='dist'

export V="${V-0}"

set -eu
cd "${0%/*}/.."
. tools/git-utils.sh

force=''
wait=''
rebase=''
while [ $# != 0 ] ; do
    case "$1" in
        --force)
            force=1;;
        --wait)
            wait=1;;
        --rebase)
            rebase=1;;
        *)
            echo "usage: $0 [--rebase] [--wait]" >&2
            exit 1
    esac
    shift
done

[ -n "${quiet}" ] || set -x

if [ -e dist ] && [ -z "${force}" ]; then
    echo "jumpstart: dist/ already exists, skipping" >&2
    exit 1
fi

if [ "${NODE_ENV-}" = "development" ]; then
    echo 'jumpstart: only works with production builds (NODE_ENV != development)' >&2
    exit 1
fi

if [ -n "$(git status --porcelain)" ]; then
    echo 'Refusing operation on an unclean tree:' >&2
    echo
    git status >&2
    exit 1
fi
# If we are rebasing and the HEAD commit is a merge, reset to the
# merged commit before proceeding.
if test -n "${rebase}" && git rev-parse --verify HEAD^2 >/dev/null; then
    git reset --hard HEAD^2
fi
tag="sha-$(git rev-parse HEAD)"

for try in $(seq 50 -1 0); do
    if fetch_to_cache tag "${tag}"; then
        break
    fi
    if [ -z "${wait}" ] || [ "$try" = '0' ]; then
        exit 1
    fi
    message WAIT 30s
    sleep 30s
done

if [ -n "${rebase}" ]; then
    merge_base="$(cat_from_cache "${tag}" merge-base)"
    # If we don't already have that commit, we'll need to go fetch it
    if ! git rev-list --quiet --objects "${merge_base}"; then
        message FETCH ".  [${merge_base}]"
        git fetch --no-write-fetch-head origin "${merge_base}"
    fi
    # EMAIL is used as a final fallback, only if nothing else is set.  This is
    # ignored if your git is properly configured, but if it's not, then this
    # will stop the rebase from failing.
    EMAIL="${EMAIL:-<>}" git rebase --autostash -- "${merge_base}"
fi

target_tree="$(cat_from_cache "${tag}" tree)"
changed_files="$(git diff --name-only "${target_tree}")"
if [ -n "${changed_files}" ]; then
    if [ -n "${rebase-}" ]; then
        echo "Internal error: even after rebase, don't have the correct tree" >&2
    else
        echo "The current working tree needs to be rebased: try --rebase" >&2
    fi
    exit 1
fi

tools/node-modules make_package_lock_json

if [ -d dist ] && [ -n "${force}" ]; then
    message 'REMOVE' dist
    rm -rf dist
fi

unpack_from_cache "${tag}"
