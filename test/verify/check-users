#!/usr/bin/python3 -cimport os, sys; os.execv(os.path.dirname(sys.argv[1]) + "/../common/pywrap", sys.argv)

# This file is part of Cockpit.
#
# Copyright (C) 2013 Red Hat, Inc.
#
# Cockpit is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# Cockpit is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.

import os

import testlib

good_password = "tqymuVh.ZfZnPÂ§9Wr=LM3JyG5yx"


def getUserAddDetails(machine):
    useradd_defaults = {}
    for line in machine.execute("useradd -D").splitlines():
        key, value = line.split("=")
        useradd_defaults[key] = value

    return useradd_defaults


def performUserAction(browser, user, action):
    browser.wait_visible(f"#accounts-list tbody tr:contains({user}) .pf-v5-c-dropdown button")
    browser.click(f"#accounts-list tbody tr:contains({user}) .pf-v5-c-dropdown button")
    browser.wait_visible(f"#accounts-list tbody tr:contains({user}) .pf-v5-c-dropdown button[aria-expanded=true]")
    browser.click(f".pf-v5-c-dropdown__menu-item:contains({action})")


def createUser(
    browser,
    machine,
    user_name,
    real_name,
    locked,
    force_password_change,
    password=None,
    custom_home_dir=None,
    default_shell=None,
    custom_shell=None,
    uid=None,
    expected_uid=None,
    verify_created=True,
    run_assert_pixels=False,
):
    if default_shell is None:
        default_shell = getUserAddDetails(machine)["SHELL"] or "/bin/bash"
    browser.wait_visible('#accounts-create')
    browser.click('#accounts-create')
    browser.wait_visible('#accounts-create-dialog')
    if run_assert_pixels:
        browser.assert_pixels("#accounts-create-dialog", "accounts-create-dialog")

    browser.set_input_text('#accounts-create-user-name', user_name)
    browser.set_input_text('#accounts-create-real-name', real_name)
    if password:
        browser.set_input_text('#accounts-create-password-pw1', password)
        browser.set_input_text('#accounts-create-password-pw2', password)

    if locked:
        browser.click('#accounts-create-locked')
        browser.wait_visible('#accounts-create-locked:checked')
    else:
        browser.wait_visible('#account-use-password:checked')
        browser.set_checked('#accounts-create-force-password-change', force_password_change)
        browser.wait_visible('#accounts-create-locked:not(:checked)')

    if expected_uid is not None:
        browser.wait_visible(f'#accounts-create-user-uid[value="{expected_uid}"]')
    if uid is not None:
        browser.set_input_text('#accounts-create-user-uid', uid)
    if custom_home_dir is not None:
        browser.set_input_text('#accounts-create-user-home-dir', custom_home_dir)
    else:
        default_home_dir = getUserAddDetails(machine)["HOME"]
        expected_home_dir = default_home_dir + "/" + user_name
        browser.wait_visible(f"#accounts-create-user-home-dir[value='{expected_home_dir}']")

    if custom_shell:
        browser.select_from_dropdown("#accounts-create-user-shell", custom_shell)
    else:
        browser.wait_visible(f"#accounts-create-user-shell[data-selected='{default_shell}']")

    browser.click('#accounts-create-dialog button.apply')

    if verify_created:
        browser.wait_not_present('#accounts-create-dialog')
        browser.wait_in_text('#accounts-list', real_name)


@testlib.nondestructive
@testlib.skipDistroPackage()
class TestAccounts(testlib.MachineCase):

    def testBasic(self):
        self._testBasic()

    def testBasic1(self):
        self._testBasic()

    def testBasic2(self):
        self._testBasic()

    def testBasic3(self):
        self._testBasic()

    def testBasic4(self):
        self._testBasic()

    def testBasic5(self):
        self._testBasic()

    def testBasic6(self):
        self._testBasic()

    def testBasic7(self):
        self._testBasic()

    def testBasic8(self):
        self._testBasic()

    def testBasic9(self):
        self._testBasic()

    def testBasic10(self):
        self._testBasic()

    def _testBasic(self):
        b = self.browser
        m = self.machine

        self.login_and_go("/users")

        # Add a user externally
        m.execute("useradd anton")
        m.execute("echo anton:foobar | chpasswd")
        with b.wait_timeout(30):
            b.wait_in_text('#accounts-list', "anton")

        # FIXME: rtl test was flaky, debug it and remove the skip
        b.assert_pixels("#users-page", "users-page", ignore=["td[data-label='Last active']", "button:contains('more...')"], skip_layouts=["rtl"])

        # There is only one badge and it is for admin
        b.wait_text('#current-account-badge', 'Your account')
        b.wait_js_cond('document.querySelector("#current-account-badge").previousSibling.getAttribute("href") === "#/admin"')

        # The current account is the first in the list
        b.wait_visible("#accounts-list > tbody :first-child #current-account-badge")

        # Set a real name
        b.go("#/anton")
        b.wait_visible("#account-locked:not([disabled])")
        b.assert_pixels("#users-page", "user-detail-page")
        b.wait_text("#account-user-name", "anton")
        b.wait_text("#account-title", "anton")
        b.wait_not_attr("#account-delete", "disabled", "disabled")
        b.set_input_text('#account-real-name', "")  # Check that we can delete the name before setting it up
        b.set_input_text('#account-real-name', "Anton Arbitrary")
        b.wait_visible('#account-real-name:not([disabled])')
        b.wait_text("#account-title", "Anton Arbitrary")
        b.wait_text("#account-home-dir", os.path.join(getUserAddDetails(m)["HOME"] + "/anton"))
        b.wait_text("#account-shell", getUserAddDetails(m)["SHELL"])
        self.assertIn(":Anton Arbitrary:", m.execute("grep anton /etc/passwd"))

        # Add some other GECOS fields
        b.set_input_text('#account-real-name', "Anton Arbitrary,1,123")
        b.wait_visible('#account-real-name:not([disabled])')
        self.assertIn(":Anton Arbitrary,1,123:", m.execute("grep anton /etc/passwd"))
        # Table title only shows real name, no other GECOS fields
        b.wait_text("#account-title", "Anton Arbitrary")
        # On the overview page it also shows only real name
        b.go("/users")
        b.wait_text('#accounts-list td[data-label="Full name"]:contains("Anton")', "Anton Arbitrary")
        b.go("/users/#anton")

        # Delete it
        b.click('#account-delete')
        b.wait_visible('#account-confirm-delete-dialog')
        b.click('#account-confirm-delete-dialog button.apply')
        b.wait_not_present('#account-confirm-delete-dialog')
        b.wait_visible("#accounts")
        b.wait_not_in_text('#accounts-list', "Anton Arbitrary")

        # Attempt a real name with a colon
        b.click('#accounts-create')
        b.wait_visible('#accounts-create-dialog')
        b.set_input_text('#accounts-create-real-name', "Col:n Colon")  # This should fail
        b.set_input_text('#accounts-create-password-pw1', good_password)
        b.set_input_text('#accounts-create-password-pw2', good_password)
        b.click('#accounts-create-dialog button.apply')
        b.wait_in_text("#accounts-create-dialog .pf-v5-c-form__helper-text .pf-m-error", "The full name must not contain colons.")
        b.click('#accounts-create-dialog button.cancel')
        b.wait_visible("#accounts")

        # Check root user
        b.go("#/root")
        b.wait_text("#account-user-name", "root")
        # some operations are not allowed for root user
        b.wait_visible("#account-delete[disabled]")
        b.wait_visible("#account-real-name[disabled]")
        b.wait_visible("#account-logout[disabled]")
        b.wait_visible("#account-locked:not(:checked)")
        # check home directory and shell for root
        b.wait_text("#account-home-dir", "/root")
        b.wait_in_text("#account-shell", "/bin/bash")  # can be /usr/bin/bash or /bin/bash
        # root account should not be locked by default on our images
        self.assertIn(m.execute("passwd -S root").split()[1], ["P", "PS"])
        # now lock account
        b.set_checked("#account-locked", val=True)
        b.wait(lambda: m.execute("passwd -S root").split()[1] in ["L", "LK"])

        # go back to accounts overview, check pf-v5-c-breadcrumb
        b.click("#account .pf-v5-c-breadcrumb a")
        b.wait_visible("#accounts-create")

        # Create a user from the UI
        self.sed_file('s@^SHELL=.*$@SHELL=/bin/true@', '/etc/default/useradd')
        b.click('#accounts-create')
        b.wait_visible('#accounts-create-dialog')
        b.set_input_text('#accounts-create-user-name', "Berta")
        b.set_input_text('#accounts-create-real-name', "Berta Bestimmt")
        b.set_input_text('#accounts-create-password-pw1', "foo")
        b.wait_visible("#accounts-create-password-meter.danger")
        b.set_input_text('#accounts-create-password-pw1', good_password)
        b.wait_visible("#accounts-create-password-meter.success")

        # Test password show/hide functionality
        b.wait_visible('#accounts-create-password-pw1[type="password"]')
        b.click("#accounts-create-password-pw1-group button[aria-label='Show password']")
        b.wait_visible('#accounts-create-password-pw1[type="text"]')
        b.click("#accounts-create-password-pw1-group button[aria-label='Hide password']")
        b.wait_visible('#accounts-create-password-pw1[type="password"]')

        # Test confirmation password show/hide functionality
        b.wait_visible('#accounts-create-password-pw2[type="password"]')
        b.click("#accounts-create-password-pw2-group button[aria-label='Show confirmation password']")
        b.wait_visible('#accounts-create-password-pw2[type="text"]')
        b.click("#accounts-create-password-pw2-group button[aria-label='Hide confirmation password']")
        b.wait_visible('#accounts-create-password-pw2[type="password"]')

        # wrong password confirmation
        b.set_input_text('#accounts-create-password-pw2', good_password + 'b')
        b.click('#accounts-create-dialog button.apply')
        b.wait_in_text("#accounts-create-dialog .pf-v5-c-form__helper-text .pf-m-error", "The passwords do not match")
        b.wait_not_present('#accounts-create-dialog button.pf-m-warning')

        # too long password
        long_password = "2a02-x!h4a" * 30
        b.set_input_text('#accounts-create-password-pw1', long_password)
        b.set_input_text('#accounts-create-password-pw2', long_password)
        b.click('#accounts-create-dialog button.apply')
        b.wait_in_text("#accounts-create-dialog .pf-v5-c-form__helper-text .pf-m-warning", "Password is longer than 256 characters")
        b.wait_not_present('#accounts-create-dialog button.pf-m-warning')

        # changing input clears the error message
        b.set_input_text('#accounts-create-password-pw1', "test")
        b.set_input_text('#accounts-create-password-pw2', "test")
        b.wait_not_present("#accounts-create-dialog .pf-v5-c-form__helper-text .pf-m-warning")

        # correct password confirmation
        b.set_input_text('#accounts-create-password-pw1', good_password)
        b.set_input_text('#accounts-create-password-pw2', good_password)
        b.click('#accounts-create-dialog button.apply')
        b.wait_not_present("#accounts-create-dialog .pf-v5-c-form__helper-text .pf-m-warning")
        b.wait_not_present('#accounts-create-dialog')
        b.wait_in_text('#accounts-list', "Berta Bestimmt")

        # Check home directory
        home_dir = m.execute("getent passwd Berta | cut -f6 -d:").strip()
        self.assertTrue(home_dir.endswith("/Berta"))
        self.assertEqual(m.execute(f"stat -c '%U' {home_dir}").strip(), "Berta")

        # Check that we set up shell configured in /etc/default/useradd
        shell = m.execute("getent passwd Berta | cut -f7 -d:").strip()
        self.assertEqual(shell, '/bin/true')

        # Delete it externally
        m.execute("userdel Berta")
        b.wait_not_in_text('#accounts-list', "Berta Bestimmt")

        b.logout()
        b.login_and_go("/users")
        createUser(
            browser=b,
            machine=m,
            user_name="robert",
            real_name="Robert Robertson",
            password=good_password,
            locked=False,
            force_password_change=True,
            default_shell="/bin/true",
            run_assert_pixels=True
        )

        # Test actions in kebab menu
        # disable password
        performUserAction(b, 'robert', 'Lock account')
        b.click("#account-confirm-lock-dialog footer .pf-m-danger.apply")
        # lock option is now disabled
        b.click("#accounts-list tbody tr:contains(robert) .pf-v5-c-dropdown button")
        b.wait_in_text(".pf-v5-c-dropdown__menu li:contains('Lock account') .pf-m-disabled", 'Lock account')
        b.click("#accounts-list tbody tr:contains(robert) .pf-v5-c-dropdown button")
        # change is visible on details page
        performUserAction(b, 'robert', 'Edit user')
        b.wait_in_text('#account-title', 'Robert Robertson')
        b.wait_visible('#account-locked:checked')
        b.click("#account-locked")
        b.go("/users")

        # In fedora-core userdel for this user consistently fails
        # userdel: user robert is currently used by process *
        if not m.ostree_image:
            performUserAction(b, 'robert', 'Delete account')
            b.click("#account-confirm-delete-dialog footer button.pf-m-danger.apply")
            b.wait_not_in_text('#accounts-list', "Robert Robertson")

        self.allow_journal_messages("Password quality check failed:")
        self.allow_journal_messages("The password is a palindrome")
        self.allow_journal_messages("passwd: user.*does not exist")
        self.allow_journal_messages("passwd: Unknown user name '.*'.")
        self.allow_journal_messages("lastlog: Unknown user or range: anton")
        # when sed'ing, there is a short time when the config file does not exist
        self.allow_journal_messages(".*libuser initialization error: .*/etc/default/useradd.*: No such file or directory")


if __name__ == '__main__':
    testlib.test_main()
