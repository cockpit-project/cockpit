<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
	"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<refentry id="api-cockpit">
  <refmeta>
    <refentrytitle>cockpit.js</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>cockpit.js</refname>
    <refpurpose>Basic cockpit API to interact with the system</refpurpose>
  </refnamediv>

  <refsection>
    <title>Loading cockpit.js</title>
    <para><code>cockpit.js</code> should be loaded via a script tag. In general jQuery should
      be loaded before <code>cockpit.js</code> as in the example below. If jQuery is not loaded
      then only the <link linkend="latest-channels">raw channel API</link> will be defined.</para>

<programlisting><![CDATA[
  <script src="../@@latest@@/jquery.js">
  <script src="../@@latest@@/cockpit.js">
]]></programlisting>
  </refsection>

  <refsection>
    <title>User Login</title>

    <refsection id="latest-logout">
      <title>cockpit.logout()</title>
<programlisting>
  cockpit.logout([reload])
</programlisting>
      <para>Logout of Cockpit. Unless <code>reload</code> is <code>false</code> this will also
        cause the page to be reloaded, so that the user can see the logged out state.</para>
    </refsection>

    <refsection id="latest-user">
      <title>cockpit.user</title>
<programlisting>
  cockpit.user["user"]
  cockpit.user["name"]
</programlisting>
      <para>This object contains information about the user that's currently logged into cockpit.
        The following fields are defined:</para>

      <variablelist>
        <varlistentry>
          <term><code>"user"</code></term>
          <listitem><para>This is the unix user like <code>"root"</code>.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"name"</code></term>
          <listitem><para>This is a readable name for the user.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>The fields will be <code>undefined</code> until a connection is made to the
        cockpit server.</para>
    </refsection>

    <refsection id="latest-info-changed">
      <title>cockpit.user.onchanged</title>
<programlisting>
  $(cockpit.user).on("changed", function() { ... })
</programlisting>
      <para>This event is fired when the user info changes or first becomes available.</para>
    </refsection>

  </refsection>

  <refsection id="latest-location">
    <title>Page Location</title>

<programlisting>
  location = cockpit.location
  cockpit.location = "/path"
</programlisting>

    <para>Cockpit components often have different views, without changing the HTML file that is
      being viewed. These are known as pages. <code>cockpit.location</code> is an object that can
      be used to read the current page and to navigate to a different page location. It works by
      updating <code>window.location.hash</code>.</para>

    <para>The <code>cockpit.location</code> looks like a HTTP path with a possible query
      string:</para>

<programlisting>
 /path/sub/page?option=value,option2
</programlisting>

    <para>The <link linkend="latest-location-path"><code>location.path</code></link> and
      <link linkend="latest-location-options"><code>location.options</code></link> contain a parsed
      form of the location. While the location cannot be modified in place, a new one can be
      created by assigning a string to <code>cockpit.location</code> or by calling the
      <link linkend="latest-location-go"><code>location.go()</code></link> function.</para>

    <para><code>cockpit.location</code> is designed similarly to <code>window.location</code>
      in that the location object is preplaced whenever the current page location changes. To be
      aware of when the page location changes listen for the
      <link linkend="latest-location-changed"><code>cockpit.onlocationchanged</code></link>
      event.</para>

    <para>Using the location object as a string will result in the
      <link linkend="latest-location-href"><code>location.href</code></link>.</para>

    <refsection id="latest-location-href">
      <title>location.href</title>
      <para>The string representation of this page location, including any options.</para>
    </refsection>

    <refsection id="latest-location-path">
      <title>location.path</title>
      <para>An array of path segments, parsed and decoded appropriately. An empty array denotes
        the root path.</para>
    </refsection>

    <refsection id="latest-location-options">
      <title>location.options</title>
      <para>A javascript object containing the various options present in the location.</para>
    </refsection>

    <refsection id="latest-location-go">
      <title>location.go()</title>
<programlisting>
  location.go(path, [options])
</programlisting>
      <para>Changes the current location to the given <code>path</code> and <code>options</code>.
        If the <code>path</code> argument is a string, it will be parsed into a path. If it is
        a relative path, then the result will be relative to the current <code>location.path</code>.
        If the <code>path</code> argument is an array of path segments, it will be treated as a
        full parsed absolute path.</para>

      <para>Any options found in a <code>path</code> will be added to those in the optional
        <code>options</code> argument, and used in the result.</para>

      <para>The location change will only take effect if the location has not changed in the
        meantime. This can be to good effect by saving a <code>cockpit.location</code> object
        and doing a conditional navigation, by calling the saved <code>location.go()</code>
        method later. This will only navigate if the user or other code has not navigated in
        the meantime.</para>
    </refsection>

    <refsection id="latest-location-replace">
      <title>location.replace()</title>
<programlisting>
  location.replace(path, [options])
</programlisting>
      <para>Similar to <link linkend="latest-location-go"><code>location.go()</code></link>
        except the location change will not result in a navigation change in the browser's
        history.</para>
    </refsection>

    <refsection id="latest-location-decode">
      <title>location.decode()</title>
<programlisting>
  path = location.decode(href, [options])
</programlisting>
      <para>Decode a cockpit href into its <code>path</code> array. If the <code>options</code>
        argument is specified, then it will be populated with options found in the href.</para>

      <para>If href is a relative path it will be resolved relative to
        <code>location.href</code>.</para>
    </refsection>

    <refsection id="latest-location-encode">
      <title>location.encode()</title>
<programlisting>
  href = location.encode(path, [options])
</programlisting>
      <para>Encode the given <code>path</code> and <code>options</code> into a cockpit href.
        The <code>path</code> argument may be an array of path segments, or a string path. If
        a relative path is passed, it will be resolved relative to <code>location.href</code>.</para>
    </refsection>

    <refsection id="latest-location-changed">
      <title>cockpit.onlocationchanged</title>
<programlisting>
 $(cockpit).on("locationchanged", function() { ... })
</programlisting>
      <para>An event emitted when over the <code>cockpit.location</code> changes. Typically a
        component reacts to this event by updating its interface to reflect the new
        <link linkend="latest-location-path"><code>cockpit.location.path</code></link> and
        <link linkend="latest-location-options"><code>cockpit.location.options</code></link>.</para>

      <para>This event is not triggered immediately during a <code>location.go()</code> or
        similar call. It will be triggered asynchronously at a later time.</para>
    </refsection>
  </refsection>

  <refsection id="latest-spawn">
    <title>Spawning Processes</title>

    <para>This is the API for spawning a process and receiving its output, as well
      as exit codes.</para>

    <refsection id="latest-spawn-spawn">
      <title>cockpit.spawn()</title>
<programlisting>
 process = cockpit.spawn(args, [options])
</programlisting>

      <para>Spawns a process on the system.</para>

      <para>The <code>args</code> should be an array starting with the executable and
        containing all the arguments to pass on the command line. If <code>args</code>
        is a string then it is interpreted as an executable name. The optional
        <code>options</code> argument is a javascript plain object and can contain
        any of the following fields:
      </para>

      <variablelist>
        <varlistentry>
          <term><code>"directory"</code></term>
          <listitem><para>The directory to spawn the process in.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"error"</code></term>
          <listitem><para>Controls where the standard error is sent. By default it is logged
            to the journal. If set to <code>"output"</code> it is included in with the
            output data.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"host"</code></term>
          <listitem><para>The remote host to spawn the process on. If no host is specified
            then the correct one will be automatically selected based on the page
            calling this function.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"environ"</code></term>
          <listitem><para>A javascript plain object that contains strings to be used as
            an environment for the new process.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"pty"</code></term>
          <listitem><para>Launch the process in its own PTY terminal, and send/receive
            terminal input and output.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"batch"</code></term>
          <listitem><para>Batch data coming from the process in blocks of at least this
              size. This is not a guarantee. After a short timeout the data will be sent
              even if the data doesn't match the batch size. Defaults to zero.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>The spawned process is a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete if the process exits successfully, or fail if there's a problem.
        Some additional methods besides the standard jQuery promise methods are documented
        below.</para>

      <para>The standard output of the process is made available via the spawned process
        object. Any non-UTF8 output from the process will be coerced into textual form.
        It is highly recommended that only textual output be produced by the command.
        The standard error is logged to the journal.</para>
    </refsection>

    <refsection id="latest-spawn-done">
      <title>process.done()</title>
<programlisting>
 process.done(function(data) { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        method. It sets up a handler to be called when the process finishes successfully.</para>
      <para>The <code>data</code> argument contains the standard output of the process.
        If any <code><link linkend="latest-spawn-stream">process.stream()</link></code>
        handlers are set up, then they will consume the standard output, and the
        <code>data</code> argument will be <code>null</code>.</para>
    </refsection>

    <refsection id="latest-spawn-fail">
      <title>process.fail()</title>
<programlisting>
 process.fail(function(exception) { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink> method.
        It sets up a handler to be called when the process fails, terminates or exits.</para>

      <para>The <code>exception</code> object passed to the handler can have the
        following fields:</para>

      <variablelist>
        <varlistentry>
          <term><code>problem</code></term>
          <listitem><para>A <link linkend="latest-problems">problem code</link> string when
            a problem occurred starting or communicating with the process. This is <code>null</code>
            if the process exited or was terminated.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>exit_status</code></term>
          <listitem><para>The numeric exit status of the process. This is <code>null</code> if
            the process did not exit.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>exit_signal</code></term>
          <listitem><para>A string representing a unix signal that caused the process to terminate.
            This is <code>null</code> if the process did not terminate because of a signal.</para></listitem>
        </varlistentry>
      </variablelist>
    </refsection>

    <refsection id="latest-spawn-always">
      <title>process.always()</title>
<programlisting>
 process.always(function() { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink> method.
        It sets up a handler to be called when when the process completes, whether it exits successfully,
        fails, terminates, or exits with a failure.</para>
    </refsection>

    <refsection id="latest-spawn-stream">
      <title>process.stream()</title>
<programlisting>
 process.stream(function(data) { ... })
</programlisting>
      <para>This sets up a handler to be called when the process has standard output. The
        handler will be called multiple times. The handler will be called regardless of
        whether the process ends up exiting successfully or not.</para>
      <para>If any <code>process.stream()</code> handlers are set up, then the
        <code><link linkend="latest-spawn-done">process.done()</link></code> handlers will
        get a <code>null</code> as their <code>data</code> argument. The stream handlers
        consume the data.</para>
    </refsection>

    <refsection id="latest-spawn-write">
      <title>process.write()</title>
<programlisting>
 process.write(data)
</programlisting>
      <para>This method writes string data to the standard input of the process.</para>
    </refsection>

    <refsection id="latest-spawn-close">
      <title>process.close()</title>
<programlisting>
 process.close([problem])
</programlisting>
      <para>Close the proces. If <code>problem</code> is not specified, then just the standard
        input of the process is closed. If <code>problem</code> is specified it should be a
        standard <link linkend="latest-problems">problem code</link> string. In this case the
        process will be terminated with a signal.</para>
    </refsection>
  </refsection>

  <refsection id="latest-problems">
    <title>Problem Codes</title>
    <para>Cockpit represents problems with standardized problem string codes.</para>
    <variablelist>
      <varlistentry>
        <term><code>"internal-error"</code></term>
        <listitem><para>An unexpected internal error without further info. This should
          not happen during the normal course of operations.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"no-cockpit"</code></term>
        <listitem><para>The system does not have a compatible version of Cockpit installed
          or installed properly.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"no-session"</code></term>
        <listitem><para>Cockpit is not logged in.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"not-authorized"</code></term>
        <listitem><para>The user is not permitted to perform the action in question.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"not-found"</code></term>
        <listitem><para>Something specifically requested was not found, such as a file,
          executable etc.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"terminated"</code></term>
        <listitem><para>Something was terminated forcibly, such as a connection, process
          session, etc.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"timeout"</code></term>
        <listitem><para>Something timed out.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"unknown-hostkey"</code></term>
        <listitem><para>The remote host had an unexpected or unknown key.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>"no-forwarding"</code></term>
        <listitem><para>Could not forward authentication credentials to the remote host.</para></listitem>
      </varlistentry>
    </variablelist>
  </refsection>

  <refsection id="latest-dbus">
    <title>DBus Access</title>

    <para>Cockpit allows access to DBus services via this API.</para>

    <para>DBus values are represented as javascript values and objects as follows:</para>

    <variablelist>
      <varlistentry>
        <term><code>BYTE 'y'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>BOOLEAN 'b'</code></term>
        <listitem><para>Javascript boolean.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>INT16 'n'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>UINT16 'q'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>INT32 'i'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>UINT32 'u'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>INT64 'x'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>UINT64 't'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>DOUBLE 'd'</code></term>
        <listitem><para>Javascript number.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>STRING 's'</code></term>
        <listitem><para>Javascript string.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>OBJECT_PATH 'o'</code></term>
        <listitem><para>Javascript string.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>SIGNATURE 'g'</code></term>
        <listitem><para>Javascript string.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>ARRAY of BYTE 'ay'</code></term>
        <listitem><para>A string containing base64 encoded data.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>ARRAY of DICT_ENTRY with STRING keys 'a{s?}'</code></term>
        <listitem><para>A javascript plain object with the keys as property names.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>ARRAY of DICT_ENTRY with other keys 'a{??}'</code></term>
        <listitem><para>A javascript plain object each key JSON encoded into a string property name.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>ARRAY of other</code></term>
        <listitem><para>A javascript array.</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><code>VARIANT</code></term>
        <listitem><para>A javascript plain object with the <code>"t"</code> property set to a DBus type string,
            and the <code>"v"</code> property set to a value.</para></listitem>
      </varlistentry>
    </variablelist>

    <refsection id="latest-dbus-dbus">
      <title>cockpit.dbus()</title>
<programlisting>
 client = cockpit.dbus(name, [options])
</programlisting>

      <para>Create a DBus client for the given bus <code>name</code> (eg: service name). Use the
        following functions to make DBus method calls, watch for events, etc. The optional
        <code>options</code> argument is a javascript plain object, and may include:</para>

      <variablelist>
        <varlistentry>
          <term><code>"bus"</code></term>
          <listitem><para>The DBus bus to connect to. Specifying <code>"session"</code> will
              connect to the DBus user session bus, <code>"user"</code> will connect to the
              user bus (on some systems this is identical to the session bus), and <code>"system"</code>
              will connect to the DBus system bus. This defaults to "system" if not
              present.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"host"</code></term>
          <listitem><para>The host to open the channel to. If no host is specified
            then the correct one will be automatically selected based on the page
            calling this function.</para></listitem>
        </varlistentry>
      </variablelist>
    </refsection>

    <refsection id="latest-dbus-close">
      <title>client.close()</title>
<programlisting>
 client.close([problem])
</programlisting>
      <para>Close the DBus client. If <code>problem</code> is specified it should be a
        <link linkend="latest-problems">problem code</link> string.</para>
    </refsection>

    <refsection id="latest-dbus-onclose">
      <title>client.onclose</title>
<programlisting>
 $(client).on("close", function(options) { ... })
</programlisting>
      <para>An event triggered when the DBus client closes. This can happen either because
        <link linkend="latest-dbus-close">client.close()</link> function was called,
        or the DBus service went away, or some other problem or disconnection.</para>
      <para>The <code>options</code> will contain various close information, including a
        <code>"problem"</code> field which will be set if the channel was closed because
        of a problem.</para>
    </refsection>

    <refsection id="latest-dbus-options">
      <title>client.options</title>
      <para>Set to the options used when creating the client. Will not change for the life of
        the client.</para>
    </refsection>

    <refsection id="latest-dbus-proxy">
      <title>client.proxy</title>
<programlisting>
 proxy = client.proxy([interface, path])
</programlisting>

      <para>Create proxy javascript object for a DBus <code>interface</code>. At the
        specified DBus object <code>path</code>. The proxy will have
        properties, methods and signals from to the DBus interface, and allows for
        natural interaction. If no <code>interface</code> is specified then the DBus
        bus name of the client is used. If no <code>path</code> is specified, then
        the DBus name of the client is converted to a path.</para>

      <para>If creating lots of proxies for a given <code>interface</code> it is more
        efficient to use the
        <link linkend="latest-dbus-proxies"><code>client.proxies()</code></link>
        function.</para>

      <para>The proxy is loaded when the
        <link linkend="latest-dbus-proxy-valid"><code>proxy.valid</code></link> field is
        <code>true</code>, and it is set to <code>false</code> if the underlying
        <code>interface</code> and/or <code>path</code> don't or no longer exist, or
        the <code>client</code> has closed. You can wait for proxy to become valid
        by passing a callback to its
        <link linkend="latest-dbus-proxy-wait"><code>proxy.wait()</code></link> function.
        The <link linkend="latest-dbus-proxy-onchanged"><code>proxy.onchanged</code></link>
        event will also fire when the proxy becomes valid or invalid. DBus properties and
        methods on the proxy are not defined until the proxy becomes valid.</para>

<programlisting>
 value = proxy.Prop1
 proxy.WritableProp = value
</programlisting>

      <para>All DBus properties on the <code>interface</code> that start with an upper case
        letter (as is convention) will be automatically defined on this proxy, and will update
        their values as the DBus property values change. In addition the
        <link linkend="latest-dbus-proxy-onchanged"><code>proxy.onchanged</code></link> event
        will fire every time the properties change.</para>

      <para>If you assign a value to a writable property on the proxy, the proxy will try to set
        that property on the DBus <code>interface</code> at <code>path</code>. The actual proxy
        property value will not update until the DBus service has notified the proxy of the
        change. If setting a property fails a warning will be logged. In order to have more
        reliable setting of properties, or track when they have been set, or if setting fails,
        use the <link linkend="latest-dbus-call"><code>client.call()</code></link> directly.
        It should be noted that DBus service implementations may also be inconsistent in
        their behavior when setting a property fails.</para>

      <para>You can access the raw property data using the
        <link linkend="latest-dbus-proxy-data"><code>proxy.data</code></link> field, including
        data for properties that do not start with an upper case letter.</para>

<programlisting>
  proxy.Method(arg1, arg2)
     .done(function(retval1, retval2) {
        ...
     })
     .fail(function(ex) {
        ...
     });
</programlisting>
      <para>All DBus methods on the <code>interface</code> that start with an upper case
        letter (as is convention) will be automatically defined on this proxy. These
        methods are called with arguments as normal javascript arguments. A
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete sucessfully when the method returns, or fail if an error occurs.
        The return values from the DBus method will be passed to the <code>done</code> handler
        function directly.</para>

      <para>Methods that do not start with an upper case letter can be invoked by using
        the usual <link linkend="latest-dbus-call"><code>client.call()</code></link> directly.</para>

<programlisting>
  $(proxy).on("Signal", function(event, arg1, arg2) {
      ...
  }(;
</programlisting>

      <para>All DBus signals on the <code>interface</code> that start with an upper case
        letter (as is convention) will be automatically emit events on this proxy. These
        events will contain the signal arguments after the standard <code>event</code>
        argument.</para>

      <para>Signals that do not start with an upper case letter can be subscribed to by
        using <link linkend="latest-dbus-subscribe"><code>client.subscribe()</code></link>
        directly.</para>
    </refsection>

    <refsection id="latest-dbus-proxy-client">
      <title>proxy.client</title>
      <para>Set to the DBus client of the proxy. Will not change for the life of
        the proxy.</para>
    </refsection>

    <refsection id="latest-dbus-proxy-path">
      <title>proxy.path</title>
      <para>Set to the DBus object path of the proxy. Will not change for the life of
        the proxy.</para>
    </refsection>

    <refsection id="latest-dbus-proxy-iface">
      <title>proxy.iface</title>
      <para>Set to the DBus interface name of the proxy. Will not change for the life
        of the proxy.</para>
    </refsection>

    <refsection id="latest-dbus-proxy-valid">
      <title>proxy.valid</title>
      <para>Set to <code>true</code> when the proxy's DBus interface is present at its
        DBus path, and all information for the proxy has loaded. Is set to <code>false</code>
        while loading, and after the proxy no longer refers a DBus interface and path.
        Also set to <code>false</code> if the <code>client</code> closes.</para>
      <para>Use the by <link linkend="latest-dbus-proxy-wait"><code>proxy.wait()</code></link>
        function to wait for a proxy to load. The
        <link linkend="latest-dbus-proxy-onchanged"><code>proxy.onchanged</code></link>
        event will also be emitted when the proxy becomes valid or invalid. DBus properties and
        methods on the proxy are not defined until the proxy becomes valid.</para>
    </refsection>

    <refsection id="latest-dbus-proxy-data">
      <title>proxy.data</title>
      <para>A plain javascript object containing all the raw property data that this
        proxy has loaded. This will be updated automatically as the proxy is notified
        of property changes from the DBus service. The
        <link linkend="latest-dbus-proxy-onchanged"><code>proxy.onchanged</code></link>
        event will be emitted when it changes.</para>
    </refsection>

    <refsection id="latest-dbus-proxy-wait">
      <title>proxy.wait()</title>
<programlisting>
 proxy.wait(function() {
   ...
 });
</programlisting>
      <para>Wait for a proxy to finish loading, and invoke the callback function when ready.
        If this method is called after a proxy has already loaded, then the callback will
        be invoked immediately. Use <code>proxy.valid</code> to determine whether the proxy
        loading resulting in a valid proxy.</para>
    </refsection>

    <refsection id="latest-dbus-proxy-onchanged">
      <title>proxy.onchanged</title>
<programlisting>
 $(proxy).on("changed", function(data) {
   ...
 });
</programlisting>
      <para>This event is emitted when the proxy's properties change.</para>

      <para>The <code>data</code> has the following form, and will only include
        properties that have changed:</para>

<programlisting>
  {
    "Prop1": "value",
    "Prop2": 5
  }
</programlisting>
    </refsection>

    <refsection id="latest-dbus-proxies">
      <title>client.proxies</title>
<programlisting>
  proxies = client.proxies([interface], [path_namespace])
</programlisting>

      <para>Create <link linkend="latest-dbus-proxy">proxy javascript objects</link> for
        a DBus interfaces. The proxes will have properties, methods and signals from
        the DBus <code>interface</code>, and allow for natural interaction. If no
        <code>interface</code> is specified then the DBus bus name of the client is used.
        If no <code>path_namespace</code> is provided then <code>"/"</code> will be used.</para>

      <para>Proxies will be automatically created for instances of the
        <code>interface</code> available at the DBus service. The optional
        <code>path_namespace</code> argument can be used to restrict the proxies for
        instances that have DBus paths which have the namespace path prefix.</para>

<programlisting>
  proxy1 = proxies["/dbus/path1"];
  proxy2 = proxies["/dbus/path2"];
  for (proxy in proxies) {
    ...
  }
</programlisting>
      <para>The returned <code>proxies</code> object will is used as a dictionary,
        and will have values containing proxies for DBus interface instances, with the
        keys being the DBus paths of those instances. It is possible to enumerate over
        the returned <code>proxies</code>.</para>

      <para>Proxies will be automatically added and removed from the <code>proxies</code>
        object as they appear and disappear in the service. The
        <link linkend="latest-dbus-proxies-onadded"><code>proxies.onadded</code></link>
        and <link linkend="latest-dbus-proxies-onremoved"><code>proxies.onremoved</code></link>
        events will be emitted. DBus services may not support notifications of paths
        disappearing.</para>

      <para>Use the <code>proxies.wait()</code> function to be notified when the initial
        set of proxies has been populated.</para>
    </refsection>

    <refsection id="latest-dbus-proxies-wait">
      <title>proxies.wait()</title>
<programlisting>
 proxies.wait(function() {
   ...
 });
</programlisting>
      <para>Wait for a <code>proxies</code> object to populate its initial set of proxies.
        If this method is called after the proxies have populated, the callback will be
        invoked immediately.</para>
    </refsection>

    <refsection id="latest-dbus-proxies-client">
      <title>proxies.client</title>
      <para>Set to the DBus client of the proxies. Will not change.</para>
    </refsection>

    <refsection id="latest-dbus-proxies-iface">
      <title>proxies.iface</title>
      <para>Set to the DBus interface name of the proxies. Will not change.</para>
    </refsection>

    <refsection id="latest-dbus-proxies-path_namespace">
      <title>proxies.path_namespace</title>
      <para>Set to the DBus path namespace used which the proxies must have as a DBus
        path prefix. Will not change.</para>
    </refsection>

    <refsection id="latest-dbus-proxies-onadded">
      <title>proxies.onadded</title>
<programlisting>
 $(proxies).on("added", function(event, proxy) {
   ...
 })
</programlisting>
      <para>This event is emitted when a proxy is added to the <code>proxies</code> object.
        The proxy will already have loaded.</para>
    </refsection>

    <refsection id="latest-dbus-proxies-onchanged">
      <title>proxies.onchanged</title>
<programlisting>
 $(proxies).on("changed", function(event, proxy) {
   ...
 })
</programlisting>
      <para>This event is emitted when one of the proxy in the <code>proxies</code> object
        changes its properties.</para>
    </refsection>

    <refsection id="latest-dbus-proxies-onremoved">
      <title>proxies.onremoved</title>
<programlisting>
 $(proxies).on("removed", function(event, proxy) {
   ...
 })
</programlisting>
      <para>This event is emitted when a proxy is removed to the <code>proxies</code> object.</para>
    </refsection>

    <refsection id="latest-dbus-call">
      <title>client.call()</title>
<programlisting>
  invocation = client.call(path, interface, method, args, [options])
</programlisting>

      <para>Make a DBus method call.</para>

      <para>The <code>path</code> is the DBus object path to make
        the call on, <code>interface</code> is the DBus interface for the method and
        <code>method</code> is the name of the method to call. The <code>args</code> is an
        array of arguments to pass to the method, each of which must be appropriate for the
        expected <link linkend="latest-dbus">DBus type</link> of that argument. The
        <code>args</code> may be <code>null</code> if no arguments are to be sent.</para>

      <para>The returned value is a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete sucessfully when the method returns, or fail if an error occurs.</para>

      <para>If <code>options</code> is specified it should be a plain javascript object,
        which may contain the following properties:</para>

      <variablelist>
        <varlistentry>
          <term><code>flags</code></term>
          <listitem><para>A string containing DBus message flags. No flags are defined at
            this time.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>type</code></term>
          <listitem><para>A valid DBus type signature to use when calling the method. In the
              absence of this, the DBus service will be introspected (and the result cached) to
              ask what the method type signature is.</para></listitem>
        </varlistentry>
      </variablelist>
    </refsection>

    <refsection id="latest-dbus-done">
      <title>invocation.done()</title>
<programlisting>
 invocation.done(function(args, options) { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        method. It sets up a handler to be called when the DBus method call finishes
        successfully.</para>
      <para>The <code>args</code> argument is an array of return values from the DBus method.
        Each of them will be converted to an appropriate
        <link linkend="latest-dbus">javascript type</link>.</para>
      <para>The <code>options</code> argument may contain additional information about the
        reply. If the <code>type</code> option was specified when performing the method call,
        then the <code>options</code> in the reply here will also contain a <code>type</code>
        field containing the DBus type signature of the output. If the <code>flags</code> option
        was specified when performing the call then the <code>options</code> in the reply here
        will contain message flags. Possible out message flags are:</para>

      <variablelist>
        <varlistentry>
          <term><code>&gt;</code></term>
          <listitem><para>A big endian message.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>&lt;</code></term>
          <listitem><para>A little endian message.</para></listitem>
        </varlistentry>
      </variablelist>

    </refsection>

    <refsection id="latest-dbus-fail">
      <title>invocation.fail()</title>
<programlisting>
 invocation.fail(function(exception) { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink> method.
        It sets up a handler to be called when the DBus method call fails.</para>

      <para>The <code>exception</code> object passed to the handler can have the
        following properties:</para>

      <variablelist>
        <varlistentry>
          <term><code>problem</code></term>
          <listitem><para>A <link linkend="latest-problems">problem code</link> string when
              a problem occurred starting or communicating with the DBus service. This is
              <code>null</code> in the cases where an actual DBus error was occurred.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>name</code></term>
          <listitem><para>The DBus error name. This will be <code>null</code> in cases where the
            failure was not due to a DBus error.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>message</code></term>
          <listitem><para>A DBus error message. This will be <code>null</code> in cases where the
            failure was not due to a DBus error.</para></listitem>
        </varlistentry>
      </variablelist>
    </refsection>

    <refsection id="latest-dbus-always">
      <title>invocation.always()</title>
<programlisting>
 invocation.always(function() { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink> method.
        It sets up a handler to be called when when the DBus method call finishes whether successfully,
        or fails.</para>
    </refsection>

    <refsection id="latest-dbus-subscribe">
      <title>client.subscribe()</title>
<programlisting>
 subscription = client.subscribe(match, function(path, interface, signal, args) { ... })
</programlisting>
      <para>Subscribe to signals. The <code>match</code> argument is a javascript plain object which
        defines what signals to subscribe to. Each property in the <code>match</code> argument restricts
        signals subscribed to. If a property is not present then it is treated as a wildcard, matching
        anything. If an empty object is specified as <code>match</code> then all signals will be
        subscribed to. The <code>match</code> argument may contain the following properties:</para>

      <variablelist>
        <varlistentry>
          <term><code>interface</code></term>
          <listitem><para>A DBus interface to match.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>path</code></term>
          <listitem><para>A DBus object path to match. May not be used together with the
            <code>path_namespace</code> property. It should be a valid DBus object path,
            that is, it should have no trailing slash.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>path_namespace</code></term>
          <listitem><para>A DBus object path prefix to match. Any paths in the hierarchy below this
            top path will match. May not be used together with the <code>path</code>
            property.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>member</code></term>
          <listitem><para>The DBus signal name to match.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>arg0</code></term>
          <listitem><para>Matches the first argument of a DBus message, which must be a
             string.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>The handler passed as the second argument will be invoked when the signal is received.
        A <code>subscription</code> is returned which can be used to remove the subscription by
        calling its <code>subscription.remove()</code> method.</para>

      <para>It is not a problem to subscribe to the same signals more than once, with identical
        or slightly different <code>match</code> arguments.</para>
    </refsection>

    <refsection id="latest-dbus-remove">
      <title>subscription.remove()</title>
<programlisting>
 subscription.remove()
</programlisting>

      <para>Unsubscribe from the DBus signal subscription.</para>
    </refsection>

    <refsection id="latest-dbus-watch">
      <title>client.watch</title>
<programlisting>
 watch = client.watch(path)
 watch = client.watch({ "path_namespace": path_namespace, "interface": interface })
</programlisting>
      <para>Watch for property and interface changes on the given DBus object
        <code>path</code> DBus <code>path_namespace</code>. If <code>interface</code> is
        specified only properties on that DBus interface will be watched.</para>

      <para>The <link linkend="latest-dbus-proxy"><code>client.proxy()</code></link> and
          <link linkend="latest-dbus-proxies"><code>client.proxies()</code></link> functions and
        the objects they return are high level wrappers around <code>client.watch()</code>.</para>

      <para>The property and interface changes will be available in raw form on the
        <link linkend="latest-dbus-onnotify"><code>client.onnotify</code></link> event.</para>

      <para>Property and interface changes that are caused by a method call or signal will
        show up before that method call reply is received, or signal event is triggered.
        It should be possible to rely on this guarantee, unless the DBus service in question
        behaves incorrectly. Internally these watches work well with code that implements the
        <ulink url="http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-objectmanager">ObjectManager</ulink>
        portion of the DBus specification. If no ObjectManager implementation is available, the
        watch falls back to using DBus
        <ulink url="http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-introspectable">Introspection</ulink> along with the usual
        <ulink url="http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties">PropertiesChanged</ulink> signal. If the DBus service implements none of these, or implements them in an
        inconsistent manner, then this function will provide inconsistent or unexpected
        results.</para>

      <para>The parameter is either a DBus <code>path</code> or a plain javascript object
        with zero or more of the following fields. If an empty javascript object is used as
        an argument, then all paths, interfaces and properties will be watched.</para>

      <variablelist>
        <varlistentry>
          <term><code>interface</code></term>
          <listitem><para>Watch properties on this DBus interface.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>path</code></term>
          <listitem><para>Watch interfaces and properties at this DBus path. May not be
              used together with the <code>path_namespace</code> property.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>path_namespace</code></term>
          <listitem><para>Watch interfaces and properties under this DBus path. It should
              be a valid DBus object path, that is, it should have no trailing slash.
              If an ObjectManager implementation is available at this interface, then it
              is used. May not be used together with the <code>path</code> property.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>The returned value is a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete sucessfully when the watch has populated its initial set of properties
        and interfaces, and these have been notified via
        <link linkend="latest-dbus-onnotify"><code>client.onnotify</code></link>.</para>

      <para>A watch can be removed by calling the
        <link linkend="latest-dbus-watch-remove"><code>watch.remove()</code></link> method on
        the returned value. If identical watches are added more than once, then they must
        also be removed the same number of times before the removal takes effect.</para>
    </refsection>

    <refsection id="latest-dbus-watch-done">
      <title>watch.done()</title>
<programlisting>
 watch.done(function() { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        method. It sets up a handler to be called when the watch has populated its initial
        properties and interfaces.</para>
    </refsection>

    <refsection id="latest-dbus-watch-fail">
      <title>watch.fail()</title>
<programlisting>
 watch.fail(function() { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        method. It sets up a handler to be called if the watch fails to populate its initial
        properties and interfaces. Note that a watch will only fail if the DBus client
        closes or is somehow disconnected. It does not fail in the case of missing
        interfaces or properties.</para>
    </refsection>

    <refsection id="latest-dbus-watch-always">
      <title>watch.always()</title>
<programlisting>
 watch.always(function() { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        method. It sets up a handler to be called when the watch has populated its initial
        properties and interfaces or has failed to do so.</para>
    </refsection>

    <refsection id="latest-dbus-watch-remove">
      <title>watch.remove()</title>
<programlisting>
 watch.remove()
</programlisting>
      <para>Remove the watch. This may not have any immediate effect if other watches are in
        place. In particular, if identical watches are added more than once, then they must
        also be removed the same number of times before the removal takes effect.</para>
    </refsection>

    <refsection id="latest-dbus-onnotify">
      <title>client.onnotify</title>
<programlisting>
 $(client).on("notify", function(data) { ... })
</programlisting>
      <para>An event triggered when
        <link linkend="latest-dbus-watch">watched</link> properties or interfaces change.</para>

      <para>The <link linkend="latest-dbus-proxy"><code>client.proxy()</code></link> and
          <link linkend="latest-dbus-proxies"><code>client.proxies()</code></link> functions and
          the objects they return are high level wrappers around the <code>data</code> provided
          by this event.</para>

      <para>The <code>data</code> has the following form:</para>

<programlisting>
  {
      "/path1": {
         "org.Interface1": {
            "Prop1": "value",
            "Prop2": 5
         },
         "org.Interface2": null
      }
  }
</programlisting>

      <para>Multiple paths may be present, each of which may have multiple interfaces, each
        of which may have multiple properties. The first time a given path and interface is
        emitted from this signal, it will have all its properties and interfaces. Thereafter
        only changes are noted. If an interface is set to <code>null</code>, then that
        interface has disappeared.</para>
    </refsection>

    <refsection id="latest-dbus-variant">
      <title>cockpit.variant()</title>
<programlisting>
 variant = cockpit.variant(type, value)
</programlisting>

      <para>A DBus variant is represented as a plain javascript object with a
        <code>"t"</code> property represesting the full DBus type of the variant,
        and a <code>"v"</code> property containting the variant value.</para>

      <para>This is a helper function for creating such a variant object.</para>
    </refsection>

    <refsection id="latest-dbus-byte-array">
      <title>cockpit.byte_array()</title>
<programlisting>
 byte_array = cockpit.byte_array(type, value)
</programlisting>

      <para>A DBus byte array is represnted as base64 data encoded in a string. This
        is a helper function for creating such a byte array.</para>
    </refsection>
  </refsection>

  <refsection id="latest-locale">
    <title>Localization</title>

    <para>Cockpit provides a
      <ulink url="https://www.gnu.org/software/gettext/"><code>gettext()</code></ulink> like
      API for easy translation of strings.</para>

    <refsection id="latest-locale-locale">
      <title>cockpit.locale()</title>
<programlisting>
 locale = cockpit.locale(po, [translate])
</programlisting>

      <para>Load locale information for a given <code>po</code> data. The data should
        be JSON data in the <ulink url="https://www.npmjs.org/package/po2json">po2json</ulink>
        format. If <code>translate</code> is set to <code>true</code> then the
        document will be scanned for translatable tags and they will be translated according
        to the strings in <code>po</code>.</para>

      <para>The returned object has various methods below, in particular the
        <link linkend="latest-locale-gettext"><code>locale.gettext()</code></link> function
        can be used to translate strings.</para>
    </refsection>

    <refsection id="latest-locale-gettext">
      <title>locale.gettext()</title>
<programlisting>
 translated = locale.gettext([context], string)
 var _ = locale.gettext
 var C_ = locale.gettext
 translated = _("string")
 translated = C_("context", "string")
</programlisting>

      <para>Lookup <code>string</code> for translation in the bundle. The translated string will
        be returned, or <code>string</code> will be returned if no such translated string is
        present. The <code>context</code> argument is an optional string used to qualify the
        string.</para>

      <para>This function can be assigned to a variable called <code>_</code> (underscore) which
        will make your code work with the typical <code>_("string")</code> syntax.</para>
    </refsection>

    <refsection id="latest-locale-noop">
      <title>locale.noop()</title>
<programlisting>
  var N_ = locale.noop
  var NC_ = locale.noop
</programlisting>

      <para>A noop function suitable for assigning to <code>N_</code> or <code>NC_</code> so that
        gettext scanners will be able to find translatable strings.</para>
    </refsection>

    <refsection id="latest-locale-ngettext">
      <title>locale.ngettext()</title>
<programlisting>
 translated = locale.ngettext([context], string1, stringN, number)
</programlisting>

      <para>Lookup a string appropriate for a pluralization form of the <code>number</code>.
        Various languages have complex pluralization forms that go far between the singular
        and plural forms speakers of English are familiar with. If no such translated
        string is found then either one of <code>string1</code> or <code>stringN</code> is
        returned according to simple pluralization rules.</para>

      <para>The <code>context</code> argument is an optional string used to qualify the string.</para>
    </refsection>
  </refsection>

  <refsection>
    <title>Utilities</title>

    <para>Various utility functions.</para>

    <refsection id="latest-locale-format">
      <title>cockpit.format()</title>
<programlisting>
 string = cockpit.format(template, args)
</programlisting>

      <para>Format a string interpolating <code>args</code> into <code>template</code> using
        shell like syntax. The <code>args</code> may be either an array or javascript object.
        The <code>template</code> can contain fields that look like <code>$name</code> or
        <code>${name}</code> or <code>$1</code>. Numeric fields are used with array
        <code>args</code>.</para>
    </refsection>
  </refsection>

  <refsection id="latest-packages">
    <title>Package Info</title>

    <para>Package information is available via this API, including access to package
      manifest data.</para>

    <refsection id="latest-packages-lookup">
      <title>cockpit.packages.lookup()</title>
<programlisting>
 lookup = cockpit.packages.lookup(name)
</programlisting>

      <para>This function starts a lookup for information about the package called
        <code>name</code>. The <code>name</code> argument may be a package name,
        an alias, or a checksum. The information may be retrieved from a cache.</para>

      <para>The return value is a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete if the lookup happens successfully, or fail if there's a
        problem.</para>
    </refsection>

    <refsection id="latest-packages-list">
      <title>cockpit.packages.all()</title>
<programlisting>
 lookup = cockpit.packages.all([expand])
</programlisting>

      <para>This function starts a lookup for information about all the packages for
        the host that this page is connected to. If <code>expand</code> is set to <code>true</code>
        then the there will be a key in the results for each possible name, alias, or checksum
        for the package. Otherwise only a distinct set of packages will be returned.</para>

      <para>The return value is a
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        that will complete if the lookup happens successfully, or fail if there's a
        problem.</para>
    </refsection>

    <refsection id="latest-packages-done">
      <title>lookup.done()</title>
<programlisting>
 lookup.done(function(pkg) { ... })
 lookup.done(function(pkgs) { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink>
        method. It sets up a handler to be called when the package lookup finishes
        successfully.</para>

      <para>The <code>pkg</code> argument contains an object with package information,
        containing the following fields.</para>

      <variablelist>
        <varlistentry>
          <term><code>checksum</code></term>
          <listitem><para>Checksum of the package or <code>null</code></para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>manifest</code></term>
          <listitem><para>The package manifest as a javascript object.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>name</code></term>
          <listitem><para>The canonical package name.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>The second form of the callback with a <code>pkgs</code> argument is invoked
        by the promise from a
        <link linkend="latest-packages-list"><code>cockpit.packages.all()</code></link>
        operation. In this case <code>pkgs</code> contains an object containing package
        information objects as properties, with package names as property names.</para>

    </refsection>

    <refsection id="latest-packages-fail">
      <title>lookup.fail()</title>
<programlisting>
 lookup.fail(function(exception) { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink> method.
        It sets up a handler to be called when the package lookup fails.</para>

      <para>The <code>exception</code> object passed to the handler will have the
        following fields:</para>

      <variablelist>
        <varlistentry>
          <term><code>problem</code></term>
          <listitem><para>A <link linkend="latest-problems">problem code</link> string when
            a problem occurred starting or communicating with the process. This is <code>null</code>
            if the process exited or was terminated.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>If a package is not found, the <code>problem</code> code will be <code>"not-found"</code>.</para>
    </refsection>

    <refsection id="latest-packages-always">
      <title>lookup.always()</title>
<programlisting>
 lookup.always(function() { ... })
</programlisting>
      <para>This is a standard
        <ulink url="http://api.jquery.com/category/deferred-object/">jQuery promise</ulink> method.
        It sets up a handler to be called when when the lookup completes, whether successfully or not.</para>
    </refsection>

  </refsection>

  <refsection id="latest-channels">
    <title>Raw Channels</title>

    <para>At a low level Cockpit communicates with the system via messages passed
      through various channels. These are usually exposed via higher level APIs,
      such as the <code><link linkend="latest-spawn">cockpit.spawn()</link></code> function.
      It is rare to use raw channels directly.</para>

    <refsection id="latest-channels-channel">
      <title>cockpit.channel()</title>
<programlisting>
 channel = cockpit.channel(options)
</programlisting>

      <para>This function creates a new channel for communication with the system.
        It returns a new channel object. The <code>options</code> argument is a
        plain object. At least the <code>"payload"</code> option is required, and
        based on the payload type, other options may be required.</para>

      <variablelist>
        <varlistentry>
          <term><code>"binary"</code></term>
          <listitem><para>Set to <code>"base64"</code> to transfer payloads encoded in
            base64 strings. Full binary support will come later. Both messages sent
            via <link linkend="latest-channels-send"><code>channel.send()</code></link>
            and those received via
            <link linkend="latest-channels-message"><code>channel.onmessage</code></link>
            should and will be base64 encoded.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"host"</code></term>
          <listitem><para>The host to open the channel to. If no host is specified
            then the correct one will be automatically selected based on the page
            calling this function.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"payload"</code></term>
          <listitem><para>The payload type for the channel. Only specific payload
            types are supported.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>The channel object returned has the following fields and methods and
        events. You should call the
        <code><link linkend="latest-channels-close">channel.close()</link></code>
        method when done with the channel.</para>

      <para>A valid channel will always be returned and the is ready to
        <code><link linkend="latest-channels-send">channel.send()</link></code>. The channel may
        <link linkend="latest-channels-close-ev">close shortly afterword</link> due
        to a failure.</para>
    </refsection>

    <refsection id="latest-channels-options">
      <title>channel.options</title>
      <para>The options used to open this channel. This should not be changed.</para>
    </refsection>

    <refsection id="latest-channels-valid">
      <title>channel.valid</title>
      <para>Will be <code>true</code> for an open channel. Will be set to <code>false</code> if the channel
        closes.</para>
    </refsection>

    <refsection id="latest-channels-send">
      <title>channel.send()</title>
<programlisting>
 channel.send(data)
</programlisting>
      <para>Send a message over the channel. The contents of the message depends on the
        payload type of the channel. The <code>data</code> will be converted to a string if not already
        a string.</para>
    </refsection>

    <refsection id="latest-channels-close">
      <title>channel.close()</title>
<programlisting>
 channel.close([options])
</programlisting>
      <para>Close the channel.</para>
      <para>If <code>options</code> is present it can be a plain javascript object
        containing additional channel close options to send to the peer. If closing for
        because of a problem, set the <code>"problem"</code> field to a
        <link linkend="latest-problems">problem code</link>. If <code>options</code>
        is not an object it will be treated as a <code>"problem"</code>.</para>
      <para>The <link linkend="latest-channels-close-ev">close event</link> will fire.
        A channel can also be closed by a peer or if the underlying transport closes.</para>
    </refsection>

    <refsection id="latest-channels-message">
      <title>channel.onmessage</title>
<programlisting>
 $(channel).on("message", function(event, data) { ... })
 channel.addEventListener("message", function(event, data) { ... })
</programlisting>
      <para>An event triggered when the channel receives a message. The message is
        passed as a string to the handler in the <code>data</code>. The contents of
        the message depends on the payload type of the channel.</para>
    </refsection>

    <refsection id="latest-channels-close-ev">
      <title>channel.onclose</title>
<programlisting>
 $(channel).on("close", function(options) { ... })
 channel.addEventListener("close", function(event, options) { ... })
</programlisting>
      <para>An event triggered when the channel closes. This can happen either because
        <link linkend="latest-channels-close">channel.close()</link> function was called,
        or if the peer closed the channel, or the underlying transport closes.</para>
      <para>The <code>options</code> will contain various close information, including a
        <code>"problem"</code> field which will be set if the channel was closed because
        of a problem.</para>
    </refsection>

    <refsection id="latest-transport-origin">
      <title>cockpit.transport.origin</title>
<programlisting>
  cockpit.transport.origin
</programlisting>
      <para>The HTTP origin that is being used by the underlying channel transport. This is
        read-only, you should not assign a value. If the browser supports
        <code>window.location.origin</code> then this will be identical to that value.</para>
    </refsection>

    <refsection id="latest-transport-options">
      <title>cockpit.transport.options</title>
<programlisting>
  cockpit.transport.options
</programlisting>
      <para>Initialization options received over the underlying channel transport. These
        will be empty until connection is properly established.</para>
    </refsection>

    <refsection id="latest-transport-close">
      <title>cockpit.transport.close()</title>
<programlisting>
  cockpit.transport.close([problem])
</programlisting>
      <para>Close the underlying channel transport. All channels open channels will close.
        The <code>problem</code> argument should be a problem code string. If not specified
        it will default to <code>"disconnected"</code>.</para>
    </refsection>

    <refsection id="latest-transport-filter">
      <title>cockpit.transport.filter()</title>
<programlisting>
  cockpit.transport.filter(function(channel, message) { ... })
</programlisting>
      <para>Add a filter to the underlying channel transport. All incoming messages will be
        passed to each of the filter callbacks that are registered.</para>
      <para>This function is rarely used.</para>
      <para>Filter callbacks are called in the order they are registered. If a filter
        callback returns <code>false</code> then the message will not be dispatched
        further, whether to other filters, or to channels, etc.</para>
       <para>The <code>channel</code> is a string with the intended
       destination of the message, and is either the frame channel for
       regular payload messages , or the value of the "channel" field
       for messages in the control channel.  The <code>message</code>
       is a string with the raw message, including all framing.</para>
    </refsection>

    <refsection id="latest-transport-inject">
      <title>cockpit.transport.inject()</title>
<programlisting>
  cockpit.transport.inject(message)
</programlisting>
      <para>Inject a message into the underlying channel transport. The <code>message</code>
        should be a string, and should be valid according to the Cockpit message protocol.</para>
      <para>This function is rarely used. In general you should only <code>inject()</code>
        messages you got from a <code><link linkend="latest-transport-filter">filter()</link></code>.</para>
    </refsection>
  </refsection>

  <refsection>
    <title>Cockpit Version Info</title>

    <refsection id="latest-info">
      <title>cockpit.info</title>
<programlisting>
  cockpit.info["version"]
  cockpit.info["build"]
</programlisting>
      <para>This object contains information about cockpit itself. Note that when cockpit is
        running on multiple servers, this only reflects the server that was connected to.
        The following fields are defined:</para>

      <variablelist>
        <varlistentry>
          <term><code>"build"</code></term>
          <listitem><para>A string containing build details.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><code>"version"</code></term>
          <listitem><para>A string containing the cockpit version number. It is almost always
            incorrect to use this to make a decision in code.</para></listitem>
        </varlistentry>
      </variablelist>

    </refsection>
  </refsection>

</refentry>
